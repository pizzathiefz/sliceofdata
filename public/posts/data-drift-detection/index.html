<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Data Drift를 발견하는 법 | sliceofdata</title>
<meta name="keywords" content="data drift, data drift detection">
<meta name="description" content="강은 흐르고 데이터는 변한다">
<meta name="author" content="pizzathief">
<link rel="canonical" href="https://sliceofdata.app/posts/data-drift-detection/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.27cad2a1c5348b9448235a32de472a54bfb4b517f58e15427dc5a1a01bf486da.css" integrity="sha256-J8rSocU0i5RII1oy3kcqVL&#43;0tRf1jhVCfcWhoBv0hto=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sliceofdata.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sliceofdata.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sliceofdata.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sliceofdata.app/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://sliceofdata.app/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://sliceofdata.app/posts/data-drift-detection/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {
  delimiters: [
    {left: '$$', right: '$$', display: true},
    {left: '$', right: '$', display: false},
    {left: '\\(', right: '\\)', display: false},
    {left: '\\[', right: '\\]', display: true}
  ],
  throwOnError: false
});"></script>
<meta property="og:url" content="https://sliceofdata.app/posts/data-drift-detection/">
  <meta property="og:site_name" content="sliceofdata">
  <meta property="og:title" content="Data Drift를 발견하는 법">
  <meta property="og:description" content="강은 흐르고 데이터는 변한다">
  <meta property="og:locale" content="ko-KR">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-02-06T11:31:39+09:00">
    <meta property="article:modified_time" content="2023-02-06T11:31:39+09:00">
    <meta property="article:tag" content="AI-ML">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data Drift를 발견하는 법">
<meta name="twitter:description" content="강은 흐르고 데이터는 변한다">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sliceofdata.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Data Drift를 발견하는 법",
      "item": "https://sliceofdata.app/posts/data-drift-detection/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Data Drift를 발견하는 법",
  "name": "Data Drift를 발견하는 법",
  "description": "강은 흐르고 데이터는 변한다",
  "keywords": [
    "data drift", "data drift detection"
  ],
  "articleBody": " 그리스의 철학자 헤라클레이토스는 “같은 강물에 두 번 발을 담글 수 없다”라는 말을 남겼다고 합니다. 강물이 끊임없이 흐르기 때문에 어떤 사람이 똑같은 자리에 서서 두번째로 발을 넣는다 한들 그건 처음과 같은 강물이 아니라는 뜻이죠. 마찬가지로 현실 세계의 데이터도 끊임없이 변화합니다. 일반적으로 ML 모델을 프로덕션 단계로 보내기 전에 우리가 원하는 수준의 성능을 보이는지를 확실히 하고 넘어가지만, 문제는 그 이후에 데이터가 변할 가능성이 크다는 것이고, 대부분의 경우 변한다는 것입니다. 모델은 적용되는 그 순간부터 학습에 사용했던 데이터와 다른 데이터를 맞닥뜨리게 됩니다. 운이 좋다면 한동안은 잘 돌아가겠지만 시간이 더 지나면 높은 확률로 테스트 결과와는 다른 성능을 보이게 될 겁니다.\n한 문장으로 짚고 넘어가면, 오늘 이 글에서 다룰 것은\n데이터나 변수 간 관계 변화로 인한 프로덕션 모델의 성능 저하\n라는 현상(Drift)입니다.\n특정 사건으로 인해 사람들의 소비가 변화하면서 모델의 예측과 동떨어지게 됨 - 이미지 출처\n이런 현상을 부르는 말은 뭐 model drift, concept drift, data drift 등으로 다양한 것 같습니다. 보통 데이터의 통계적인 특성이 변화하는 걸 일반적인 용어로 concept drift로 일컫는 것 같고, 아래에서 조금 더 자세히 다루겠지만 여러 개념으로 쪼개서 각각 다른 이름을 붙이기도 하는 듯합니다.\n아무튼 이 글은 주로 drift가 발생했을 때 이를 발견할 수 있는 방법들을 다룰 건데요. 들어가기 전에 그걸 왜 발견해야 돼? 라는 생각을 할 수도 있겠습니다. 어차피 필연적으로 데이터가 변화하는 거라면 그냥 최신 데이터에 맞게 계속 모델을 다시 학습시키면 되는 거 아닌가?\n물론 그냥 때마다 모델 다시 학습시키도 가능한 해결책이 될 수 있겠습니다. 하지만 모델 학습이나 데이터 획득에 큰 비용이 드는 경우, 시간이 지났다는 이유만으로 그 리소스를 들여서 무조건 재학습을 하는 것은 비효율적인 선택이라고 할 수 있습니다. 적절한 주기를 찾는 것도 하나의 큰 과제일 수 있겠고요.\n또한 모델과 상호작용하여 데이터의 변화가 일어났다면, 그 변화의 양상을 전혀 모르는 채로 단순히 처음 모델링을 할 때의 프로세스를 처음부터 다시 거치는 것만으로는 문제가 해결되지 않거나, 헤매게 될 수도 있습니다. 예를 들어 사기 거래 여부를 분류하는 모델을 만들었고, 해당 모델이 제법 성능이 좋아서 그 분류 결과를 통해 사기꾼들이 거래하지 못하도록 조치를 취했다고 칩시다. 이런 영역의 문제점은 나쁜 사람들은 보통 즉각적으로 반응을 한다는 것입니다. 만약 모델이 사기라고 분류한 케이스 중 대다수가 백 만원 이상의 고액 결제건이었다면, 앞으로 사기를 치고 싶은 사람들은 안 걸리게 십 만원씩 쪼개서 거래를 해볼까? 라고 생각할 수 있습니다. 우리가 만약 건당 결제 금액그 데이터의 분포 변화를 감지하고 어떻게 바뀌었는지 분석할 수 없다면 모델을 개선하는 데 어려움이 있겠죠 (사실 제가 맨날 겪는 일임).\n결론적으로 데이터의 변화가 어떤 변수에서 어떤 방향으로 일어났는지 발견하고, 그게 현재 모델의 성능에 어떤 방식으로 영향을 끼치고 있는지 파악해야 보다 효과적이면서도 비용을 낭비하지 않는 해결책을 찾아낼 수 있습니다.\nDrift의 종류 크게 2가지 기준으로 구분해볼 수 있습니다.\n개념적인 구분\nDrift를 간단한 공식으로 나타낸다면, 어떤 방식으로든 타겟 변수(y)와 사용한 피쳐(X)의 관계의 분포가 변화한다는 것을 뜻함 즉 결합확률분포의 변화 : $P_{t}(X,y)!= P_{t+}(X,y)$ 이걸 쪼개보면, $P(X)$의 변화 ( Covariate drift, Data drift ) : 인풋 피쳐의 분포가 변하는 경우 ex) 이탈율 예측을 하는데 예전에는 2-30대가 주로 이용하던 상품인데 트렌드의 변화 등으로 인해 요즘은 3-40대로 타겟 고객이 변화했을 때. 인풋 중 하나인 ‘나이’의 분포가 변화함 이미지 출처\n$P(y)$ 의 변화 ( Label drift, Prior probability shift ): 타겟 변수의 분포가 변하는 경우 $P(y|X)$ 의 변화 (Concept drift, Conditional change, Posterior class shift) : 인풋과 타겟 변수의 관계가 변하는 경우 - 가장 발견하고 규명하기 어려운 종류의 변화 이미지 출처\n이런 것들을 개념적으로 쪼개 보는 이유는 다음과 같이 데이터의 변화가 반드시 모델의 결정경계를 건드리지는 않는 경우도 있기 때문! 이미지 출처\n양상에 따른 구분\n다음 그림을 보면 쉽게 이해됨 이미지 출처\nDrift가 발생하는 이유? 다음은 흔히 언급되는 drift를 유발하는 원인들입니다.\n학습 데이터 자체의 샘플링 편향이 있어서 잘못된 데이터 파이프라인이나 버그 등 테크니컬한 이슈가 있어서 명시적으로 사용한 피쳐가 아닌 숨겨진 변수가 변해서 ex) 놀이공원에 온 사람의 수를 예측하는데 날씨나 요일, 휴일 여부를 사용했는데 전반적으로 경기가 안 좋아진다면? 그냥 외부 환경 자체가 바뀌어서 모델 자체의 영향, 숨겨진 피드백 루프가 있어서 공격에 대응하는 목적의 분류 문제(스팸 필터링, 네트워크 침입, 사기 탐지)에서 공격자가 모델에서 1로 분류되는 걸 피하기 위해 명확히 노력하는 경우 마케팅 캠페인처럼 사용자에게 직접 영향을 주는 경우 ex) 이탈 예측을 했는데 이탈할 고객에게 쿠폰을 줘서 이탈을 안 했다면? 도메인적인 변화 ex) 인플레이션이 오면 소득이나 물가 자체가 가지는 의미가 변경됨 어떻게 발견하는가 기본적으로는 비교 대상인 분포 2개의 데이터가 있어야 합니다. 즉 내가 비교하려고 하는 분포(Tested distribution)이 있고, 그게 뭐에 비해서 달라진 것이냐? 를 보는 근거 분포(Reference distribution)를 나누어 볼 수 있는데요. 보통 tested distribution이 아마 더 최신의 데이터일 것이고, reference distribution은 보다 이전의 데이터이거나(ex.전주 동일 요일) 학습에 사용했던 데이터 등 과거의 데이터를 의미합니다.\n시간이 흐름에 따라 매번 이전의 데이터와 비교를 하겠다면 sliding window로 일정 시간 텀마다 비교할 수 있겠죠? 그렇다면 그 주기를 정하는 것도 중요한 문제입니다(ex. 1분 전? 어제? 전주? 전달?). 타이밍을 줄일수록 빠르게 drift를 발견할 수 있겠지만 노이즈도 많아지기 때문입니다. 이 가게에 원래 금요일 밤에는 30대 직장인이 많이 방문하는데, 어제(목요일 밤)과 분포가 다르다고 문제가 생겼다고 볼 수는 없듯이요.\n한달에 한번, 전주의 같은 요일과 비교하기 - 이미지 출처\n어쨌든 이런 것들을 정했다고 치고, 이제 일정 주기마다 데이터를 비교해서 drift가 발생할 경우 나에게 얼럿을 주는 시스템을 상상해 봅시다. 이런 시스템이라면 결국 drift의 정도를 하나의 단일한 값으로 나타내주고 그 값에 대해 이 정도를 넘으면 경고다! 라는 임계값(threshold)를 정할 필요가 있겠죠.\n분포 간 통계적 차이를 계산해보자 간단한 접근으로, 각각의 피쳐에 대해 단변량으로 접근해서 하나하나 모니터링할 수 있겠습니다. 이때는 각각의 drift 정도를 수치화한 다음 하나의 값으로 집계하고, 이때 피쳐 중요도에 따라 가중치를 둬도 좋을 듯합니다.\n따라서 두 개의 데이터를 놓고 그 분포가 얼마나 떨어져 있는지 거리를 수치화하는 다음과 같은 방법들이 필요하겠습니다.\nKolmogorov-Smirnov Test (K-S Test) 보통 정규성 검정 방법으로 많이 알려져 있지만 원하는 분포-정규분포(1-sample) 간 검정 뿐 아니라 2개의 데이터가 같은 분포에서 나왔는지도 검정이 가능함(2-sample) 이미지 출처\n누적분포함수를 그림으로 그려보면 저 검은색 선인 둘 사이의 거리 D를 통계량으로 테스트함 $D_{n,m} = \\sup \\mid F_{1,n}(x) - F_{2,m}(x) \\mid$ 쉽게 쓰면 그냥 두 누적분포의 최대 차이라는 뜻 영가설은 두 데이터의 분포 간 차이가 없다 (p값이 유의수준 이하일 경우 기각되어 차이가 있다) from scipy.stats import ks_2samp 로 쓸 수 있음 PSI (population stability Index) $\\text{PSI} = \\sum((\\text{Tested} - \\text{Reference}) \\times \\ln (\\frac{\\text{Tested}}{\\text{Reference}}))$ 간단한 예시 - 지난주에는 페퍼로니 피자 주문 고객이 전체의 60% 였는데 이번주는 30% 라고 한다면 위 공식에 tested = 30%, reference = 60%로 계산해볼 수 있고 이걸 모든 메뉴에 대해 계산해서 합하면 됨 이미지 출처\n카테고리컬한 분포 또는 bin으로 나눈 데이터에 쓰기 편한 지표고 구현도 그냥 하면 될 듯. 다음과 같이 알려진 공식도 있음 $\\text{PSI} \u003c 0.1$ : 변화 없다 $\\text{PSI} \u003c 0.2$ : 약간 변화했다 $\\text{PSI} \\ge 0.2$ : 심하다 너 경고 Jensen-Shannon Diveregence (JS Divergence) Kullback-Leibler Divergence (KL Divergence)의 대칭 버전 KL Divergence의 아이디어는 한 분포를 다른 분포로 근사할 경우에 얼마나 정보 손실이 발생하느냐? (즉 두 분포가 매우 비슷하다면 손실이 별로 없을 것이고, 다르다면 많이 발생할 것이고) $D_{KL}(p\\mid q) = \\sum {p(x_i)\\cdot (\\log p(x_i)-\\log q(x_i))}$ 두 분포 차이에 대한 기대값 이걸 쪼개면 p 입장에서 q에 대한 크로스 엔트로피 - p의 엔트로피 다만 $D_{KL}$ 함수는 거리 함수로 볼 수 없는데, 대칭이 아니어서 = A와 B 의 아웃풋과 B와 A의 아웃풋이 달라서 (A를 B로 근사하느냐 B를 A로 근사하느냐) JSD는 다음과 같이 KLD를 양쪽으로(각 분포를 두 분포의 평균으로 근사) 구한 뒤 평균내서 하나의 값으로 만들어준 것 $\\text{JSD}(p,q) = \\frac{1}{2}D_{KL}(p \\mid \\frac{p+q}{2}) + \\frac{1}{2}D_{KL}(q \\mid \\frac{p+q}{2})$ rom scipy.spatial.distance import jensenshannon 로 쓸 수 있음 다만 이런 단변량적 시야에는 한계가 몇 가지 있습니다.\n피쳐가 엄-청 많다면 계속 이걸 하나하나 비교하는 로직을 돌리는 게 낭비 아닐까? 상관관계가 높은 변수들은 한꺼번에 drift될 수 있는데 이게 최종적인 drift 점수에 redundant하게 반영되지 않을까? 다변량적으로(변수가 상호작용하여) 발생하는 drift는 놓치지 않을까? 모델의 오차를 모니터링하자 단변량 접근 말고 통째로 모델 단위로 접근하는 방법을 생각해 봅시다. 모델 학습에 비용이 크게 들지 않는 상황이라면 비교 대상인 두 개의 데이터를 놓고, 따로 모델을 학습시켜서 얼마나 두 개의 모델이 동의하지 않는지(성능이든 피쳐 중요도든)를 수치화해볼 수 있습니다. 하지만 모델 재학습을 최대한 효율적으로 하려고 drift를 사전에 발견하려는 게 아닌가? 싶으니 이건 그렇게 좋은 방법이 아닐 수도 있겠어요.\n아니면 시간의 흐름에 따라 모델의 틀림 자체를 모니터링할 수도 있겠죠. 다음 방법들은 scikit-multiflow 로 쉽게 써볼 수 있습니다.\n오차 모니터링 예시 - 이미지 출처\nDDM (Drift Detection Method) 모델이 틀린다/틀리지 않는다를 binomial 변수로 봄 이항분포를 생각해보자 - $n$번 맞힐 때 독립적으로 $p$의 확률로 틀리거나, 틀리지 않는 $p_t$ : 테스트 시점의 오차율(error rate) 즉 틀림의 기댓값과 편차를 이항분포의 공식에 따라 정의할 수 있다는 뜻 $\\mu = np_t$ $\\sigma = \\sqrt{\\frac{p_t(1-p_t)}{n}}$ 그러면 다음과 같이 지금까지 기록된 오차율 최소값 + 그때 k*편차와 비교했을 때 테스트 시점의 오차율 + 편차가 커져버릴 때 알람을 주는 임계값 설정이 가능 경고: $p_t + \\sigma_t \\ge p_{min} + 2\\sigma_{min}$ 찐 알람: $p_t + \\sigma_t \\ge p_{min} + 3\\sigma_{min}$ EDDM (Early Drift Detection Method) 접근은 DDM과 유사하나 DDM에 비해 점진적인 drift를 더 잘 잡아낼 수 있다고 함 알람을 주는 기준은 테스트 오차율+그때 2*편차가 오차율 최고값+그때 2*편차와 매우 가까워질 때 경고: $\\frac{p_t + 2\\sigma_t}{p_{max}+2\\sigma_{max}}\u003c \\alpha$ 찐 알람: $\\frac{p_t + 2\\sigma_t}{p_{max}+2\\sigma_{max}}\u003c \\beta$ $\\alpha$, $\\beta$ 는 사용자가 정하는 임계치고, 보통 $\\alpha$ 0.95, $\\beta$ 0.9가 보통 디폴트 (모든 임계치가 그렇듯 빠르게 drift를 알리고 어느 정도의 false alarm을 감수할 것이냐의 trade-off는 당연히 존재함) PHT (Page-Hinkley Test) 기본적으로 지금 값이 이전 값들에서 현저하게 떨어진 값일 경우 알람을 주는 로직 단방향(커지는 것만 체크)이지만, 모델 drift를 발견하는 목적으로 오차가 커지는 걸 탐지하는 데 이 테스트를 사용한다면 굳이 양방향일 필요 없을 듯 CUSUM Test에 기반 $g_0 = 0$ 이고, $g_t =$ $\\max(0, g_{t-1} + (z_t -v))$ $g$는 모델의 아웃풋(예를 들어 오차)를 뜻함 $z$는 지금까지 시퀀스를 기반으로 계산된 기대값, 편차를 사용한 표준화값 ($z =(x-\\mu)/\\sigma$) $v$는 설정되어야 하는 파라미터인데, 보통 발견해야 하는 수준의 변화의 1/2 정도를 설정한다고 함 (단 표준편차 단위임을 유의) $g_t \u003e h$이면 알람을 주고 $g_t=0$ 으로 리셋한다! 이때 $h$는 설정해야 하는 임계치 파라미터인데, 보통 용인 가능한 false alarm 비율이 $\\delta$ 라고 치면 $\\ln(1/\\delta)$ 로 설정한다고 함 CUSUM은 memoryless하므로(직전 값만 고려) 이를 보완한 것이 PH Test $g_0 = 0$ 이고, $g_t =$ $g_{t-1} + (z_t -v)$, $G_t = \\min(g_t, G_{t-1})$ $G_t$는 $t$까지 가장 작은 값이 되도록 설정하므로 전체 앞선 시퀀스를 다 고려할 수 있음 $g_t-G_t \u003e h$ 이면 알람을 주고 $g_t = 0$으로 리셋한다! 다만, 이렇게 모델 단위로 drift를 발견해도, 결국 뭐가 어떻게 문제인지 알아내고 싶다면 각각의 피쳐로 drill down해서 보고 분포의 차이를 명확히 검증해 봐야 하는 경우가 많을 것 같다는 생각도 드네요.\n차원 축소 후 데이터를 복구해보자 또다른 아이디어로는 데이터셋을 PCA 등으로 차원 축소한 다음 복구를 해볼 수도 있습니다. 데이터가 어떻게든 많이 바뀌었다면(PCA가 배운 분산의 형태에서 많이 떨어지게 되었다면) 복구 데이터의 오차가 커질 것이라고 가정하여, 원래 데이터포인트와 복구된 데이터 간의 유클리디언 거리를 drift 점수로 쓰는 것입니다.\n모델 성능 예측과 모니터링에 쓰이는 NannyML 패키지 공식 문서에 PCA를 사용한 방법으로 다변량 drift를 발견한 예시가 있어서 가져와봤습니다.\n별로 현실적인 예시는 아니지만 이런 식으로 두 개의 피쳐의 관계가 휙 돌아가(?) 버렸다면 분명 drift가 일어난 건 맞는데, 위와 우측에 그려진 각각의 단변량 분포를 보면 각각의 피쳐 내에서는 분포가 바뀐 것처럼 보이지가 않습니다. 이럴 때 앞서 언급한 PCA 방법을 쓰면, 다음과 같이 복구 오차가 증가하는 것을 볼 수 있습니다.\n참고한 글들 Model Drift in Machine Learning: How to Detect and Avoid It Everything you need to know about drift in machine learning 8 Concept Drift Detection Methods Concept Drift Deep Dive: How to Build a Drift-Aware ML System Multivariate Data Drift Detection ",
  "wordCount" : "1753",
  "inLanguage": "ko",
  "datePublished": "2023-02-06T11:31:39+09:00",
  "dateModified": "2023-02-06T11:31:39+09:00",
  "author":{
    "@type": "Person",
    "name": "pizzathief"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sliceofdata.app/posts/data-drift-detection/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "sliceofdata",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sliceofdata.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sliceofdata.app/" accesskey="h" title="slice.of.data (Alt + H)">
                <img src="https://sliceofdata.app/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">slice.of.data</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://sliceofdata.app/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sliceofdata.app/archives/" title="posts">
                    <span>posts</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/about/" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/subscribe" title="subscribe">
                    <span>subscribe</span>
                </a>
            </li>
            <li>
                <a href="https://pizzathief.pages.dev/" title="notes">
                    <span>notes</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Data Drift를 발견하는 법
    </h1>
    <div class="post-meta"><span title='2023-02-06 11:31:39 +0900 KST'>2023-02-06</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;pizzathief&nbsp;|&nbsp;<a href="https://github.com/pizzathiefz/sliceofdata/blob/main/content/posts/data-drift-detection/index.ko.md" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#drift의-종류">Drift의 종류</a></li>
    <li><a href="#drift가-발생하는-이유">Drift가 발생하는 이유?</a></li>
    <li><a href="#어떻게-발견하는가">어떻게 발견하는가</a>
      <ul>
        <li><a href="#분포-간-통계적-차이를-계산해보자">분포 간 통계적 차이를 계산해보자</a></li>
        <li><a href="#모델의-오차를-모니터링하자">모델의 오차를 모니터링하자</a></li>
        <li><a href="#차원-축소-후-데이터를-복구해보자">차원 축소 후 데이터를 복구해보자</a></li>
      </ul>
    </li>
    <li><a href="#참고한-글들">참고한 글들</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/this-is-fine.png#center" width="480"/> 
</figure>

<br>
<p>그리스의 철학자 헤라클레이토스는 “같은 강물에 두 번 발을 담글 수 없다”라는 말을 남겼다고 합니다. 강물이 끊임없이 흐르기 때문에 어떤 사람이 똑같은 자리에 서서 두번째로 발을 넣는다 한들 그건 처음과 같은 강물이 아니라는 뜻이죠. 마찬가지로 <strong>현실 세계의 데이터도 끊임없이 변화</strong>합니다. 일반적으로 ML 모델을 프로덕션 단계로 보내기 전에 우리가 원하는 수준의 성능을 보이는지를 확실히 하고 넘어가지만, 문제는 그 이후에 데이터가 변할 가능성이 크다는 것이고, 대부분의 경우 변한다는 것입니다. 모델은 적용되는 그 순간부터 학습에 사용했던 데이터와 다른 데이터를 맞닥뜨리게 됩니다. 운이 좋다면 한동안은 잘 돌아가겠지만 시간이 더 지나면 높은 확률로 테스트 결과와는 다른 성능을 보이게 될 겁니다.</p>
<p>한 문장으로 짚고 넘어가면, 오늘 이 글에서 다룰 것은</p>
<blockquote>
<p><em><strong>데이터나 변수 간 관계 변화로 인한 프로덕션 모델의 성능 저하</strong></em></p></blockquote>
<p>라는 현상(Drift)입니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/sudden-concept-drift.png#center"
         alt="특정 사건으로 인해 사람들의 소비가 변화하면서 모델의 예측과 동떨어지게 됨 - 이미지 출처" width="600"/> <figcaption>
            <p>특정 사건으로 인해 사람들의 소비가 변화하면서 모델의 예측과 동떨어지게 됨 - <a href="https://www.evidentlyai.com/blog/machine-learning-monitoring-data-and-concept-drift">이미지 출처</a></p>
        </figcaption>
</figure>

<p>이런 현상을 부르는 말은 뭐 model drift, concept drift, data drift 등으로 다양한 것 같습니다. 보통 데이터의 통계적인 특성이 변화하는 걸 일반적인 용어로 concept drift로 일컫는 것 같고, 아래에서 조금 더 자세히 다루겠지만 여러 개념으로 쪼개서 각각 다른 이름을 붙이기도 하는 듯합니다.</p>
<p>아무튼 이 글은 주로 drift가 발생했을 때 이를 발견할 수 있는 방법들을 다룰 건데요. 들어가기 전에 그걸 왜 발견해야 돼? 라는 생각을 할 수도 있겠습니다. 어차피 필연적으로 데이터가 변화하는 거라면 그냥 최신 데이터에 맞게 계속 모델을 다시 학습시키면 되는 거 아닌가?</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/drift-retrain.png#center" width="340"/> 
</figure>

<p>물론 그냥 때마다 모델 다시 학습시키도 가능한 해결책이 될 수 있겠습니다. 하지만 모델 학습이나 데이터 획득에 큰 비용이 드는 경우, 시간이 지났다는 이유만으로 그 리소스를 들여서 무조건 재학습을 하는 것은 비효율적인 선택이라고 할 수 있습니다. 적절한 주기를 찾는 것도 하나의 큰 과제일 수 있겠고요.</p>
<p>또한 모델과 상호작용하여 데이터의 변화가 일어났다면, 그 변화의 양상을 전혀 모르는 채로 단순히 처음 모델링을 할 때의 프로세스를 처음부터 다시 거치는 것만으로는 문제가 해결되지 않거나, 헤매게 될 수도 있습니다. 예를 들어 사기 거래 여부를 분류하는 모델을 만들었고, 해당 모델이 제법 성능이 좋아서 그 분류 결과를 통해 사기꾼들이 거래하지 못하도록 조치를 취했다고 칩시다. 이런 영역의 문제점은 나쁜 사람들은 보통 즉각적으로 반응을 한다는 것입니다. 만약 모델이 사기라고 분류한 케이스 중 대다수가 백 만원 이상의 고액 결제건이었다면, 앞으로 사기를 치고 싶은 사람들은 <em>안 걸리게 십 만원씩 쪼개서 거래를 해볼까</em>? 라고 생각할 수 있습니다. 우리가 만약 건당 결제 금액그 데이터의 분포 변화를 감지하고 어떻게 바뀌었는지 분석할 수 없다면 모델을 개선하는 데 어려움이 있겠죠 (사실 제가 맨날 겪는 일임).</p>
<p>결론적으로 데이터의 변화가 어떤 변수에서 어떤 방향으로 일어났는지 발견하고, 그게 현재 모델의 성능에 어떤 방식으로 영향을 끼치고 있는지 파악해야 보다 효과적이면서도 비용을 낭비하지 않는 해결책을 찾아낼 수 있습니다.</p>
<br>
<h2 id="drift의-종류">Drift의 종류<a hidden class="anchor" aria-hidden="true" href="#drift의-종류">#</a></h2>
<p>크게 2가지 기준으로 구분해볼 수 있습니다.</p>
<ol>
<li>
<p><strong>개념적인 구분</strong></p>
<ul>
<li>Drift를 간단한 공식으로 나타낸다면, 어떤 방식으로든 타겟 변수(y)와 사용한 피쳐(X)의 관계의 분포가 변화한다는 것을 뜻함
<ul>
<li>즉 결합확률분포의 변화 : $P_{t}(X,y)!= P_{t+}(X,y)$</li>
</ul>
</li>
<li>이걸 쪼개보면,
<ul>
<li>$P(X)$의 변화 ( Covariate drift, Data drift ) : 인풋 피쳐의 분포가 변하는 경우
<ul>
<li>ex) 이탈율 예측을 하는데 예전에는 2-30대가 주로 이용하던 상품인데 트렌드의 변화 등으로 인해 요즘은 3-40대로 타겟 고객이 변화했을 때. 인풋 중 하나인 ‘나이’의 분포가 변화함</li>
<li><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/concept-drift-ex.png#center"
         alt="이미지 출처" width="480"/> <figcaption>
            <p><a href="https://nimblebox.ai/blog/machine-learning-model-drift">이미지 출처</a></p>
        </figcaption>
</figure>
</li>
</ul>
</li>
<li>$P(y)$ 의 변화 ( Label drift, Prior probability shift ): 타겟 변수의 분포가 변하는 경우</li>
<li>$P(y|X)$ 의 변화 (Concept drift, Conditional change, Posterior class shift) : 인풋과 타겟 변수의 관계가 변하는 경우 - 가장 발견하고 규명하기 어려운 종류의 변화
<ul>
<li><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/concept-drift-ex2.png#center"
         alt="이미지 출처" width="340"/> <figcaption>
            <p><a href="https://towardsdatascience.com/data-drift-explainability-interpretable-shift-detection-with-nannyml-83421319d05f">이미지 출처</a></p>
        </figcaption>
</figure>
</li>
</ul>
</li>
</ul>
</li>
<li>이런 것들을 개념적으로 쪼개 보는 이유는 다음과 같이 데이터의 변화가 반드시 모델의 결정경계를 건드리지는 않는 경우도 있기 때문!
<ul>
<li><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/concept-drift-ex3.png#center"
         alt="이미지 출처" width="480"/> <figcaption>
            <p><a href="https://dl.acm.org/doi/10.1145/2523813">이미지 출처</a></p>
        </figcaption>
</figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>양상에 따른 구분</strong></p>
<ul>
<li>다음 그림을 보면 쉽게 이해됨
<ul>
<li><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/concept-drift-classification.png#center"
         alt="이미지 출처" width="630"/> <figcaption>
            <p><a href="https://www.analyticsvidhya.com/blog/2021/10/mlops-and-the-importance-of-data-drift-detection/">이미지 출처</a></p>
        </figcaption>
</figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>
<h2 id="drift가-발생하는-이유">Drift가 발생하는 이유?<a hidden class="anchor" aria-hidden="true" href="#drift가-발생하는-이유">#</a></h2>
<p>다음은 흔히 언급되는 drift를 유발하는 원인들입니다.</p>
<ul>
<li>학습 데이터 자체의 샘플링 편향이 있어서</li>
<li>잘못된 데이터 파이프라인이나 버그 등 테크니컬한 이슈가 있어서</li>
<li>명시적으로 사용한 피쳐가 아닌 숨겨진 변수가 변해서
<ul>
<li>ex) 놀이공원에 온 사람의 수를 예측하는데 날씨나 요일, 휴일 여부를 사용했는데 전반적으로 경기가 안 좋아진다면?</li>
</ul>
</li>
<li>그냥 외부 환경 자체가 바뀌어서</li>
<li>모델 자체의 영향, 숨겨진 피드백 루프가 있어서
<ul>
<li>공격에 대응하는 목적의 분류 문제(스팸 필터링, 네트워크 침입, 사기 탐지)에서 공격자가 모델에서 1로 분류되는 걸 피하기 위해 명확히 노력하는 경우</li>
<li>마케팅 캠페인처럼 사용자에게 직접 영향을 주는 경우
<ul>
<li>ex) 이탈 예측을 했는데 이탈할 고객에게 쿠폰을 줘서 이탈을 안 했다면?</li>
</ul>
</li>
</ul>
</li>
<li>도메인적인 변화
<ul>
<li>ex) 인플레이션이 오면 소득이나 물가 자체가 가지는 의미가 변경됨</li>
</ul>
</li>
</ul>
<br>
<h2 id="어떻게-발견하는가">어떻게 발견하는가<a hidden class="anchor" aria-hidden="true" href="#어떻게-발견하는가">#</a></h2>
<p>기본적으로는 비교 대상인 분포 2개의 데이터가 있어야 합니다. 즉 내가 비교하려고 하는 분포(<strong>Tested distribution</strong>)이 있고, 그게 뭐에 비해서 달라진 것이냐? 를 보는 근거 분포(<strong>Reference distribution</strong>)를 나누어 볼 수 있는데요. 보통 tested distribution이 아마 더 최신의 데이터일 것이고, reference distribution은 보다 이전의 데이터이거나(ex.전주 동일 요일) 학습에 사용했던 데이터 등 과거의 데이터를 의미합니다.</p>
<p>시간이 흐름에 따라 매번 이전의 데이터와 비교를 하겠다면 sliding window로 일정 시간 텀마다 비교할 수 있겠죠? 그렇다면 그 주기를 정하는 것도 중요한 문제입니다(ex. 1분 전? 어제? 전주? 전달?). 타이밍을 줄일수록 빠르게 drift를 발견할 수 있겠지만 노이즈도 많아지기 때문입니다. 이 가게에 원래 금요일 밤에는 30대 직장인이 많이 방문하는데, 어제(목요일 밤)과 분포가 다르다고 문제가 생겼다고 볼 수는 없듯이요.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/window.png#center"
         alt="한달에 한번, 전주의 같은 요일과 비교하기 - 이미지 출처" width="480"/> <figcaption>
            <p>한달에 한번, 전주의 같은 요일과 비교하기 - <a href="https://superwise.ai/blog/data-drift-detection-basics/">이미지 출처</a></p>
        </figcaption>
</figure>

<p>어쨌든 이런 것들을 정했다고 치고, 이제 일정 주기마다 데이터를 비교해서 drift가 발생할 경우 나에게 얼럿을 주는 시스템을 상상해 봅시다. 이런 시스템이라면 결국 drift의 정도를 하나의 단일한 값으로 나타내주고 그 값에 대해 이 정도를 넘으면 경고다! 라는 임계값(threshold)를 정할 필요가 있겠죠.</p>
<br>
<h3 id="분포-간-통계적-차이를-계산해보자">분포 간 통계적 차이를 계산해보자<a hidden class="anchor" aria-hidden="true" href="#분포-간-통계적-차이를-계산해보자">#</a></h3>
<p>간단한 접근으로, 각각의 피쳐에 대해 단변량으로 접근해서 하나하나 모니터링할 수 있겠습니다. 이때는 각각의 drift 정도를 수치화한 다음 하나의 값으로 집계하고, 이때 피쳐 중요도에 따라 가중치를 둬도 좋을 듯합니다.</p>
<p>따라서 두 개의 데이터를 놓고 그 분포가 얼마나 떨어져 있는지 거리를 수치화하는 다음과 같은 방법들이 필요하겠습니다.</p>
<ul>
<li><strong>Kolmogorov-Smirnov Test (K-S Test)</strong>
<ul>
<li>보통 정규성 검정 방법으로 많이 알려져 있지만 원하는 분포-정규분포(1-sample) 간 검정 뿐 아니라 2개의 데이터가 같은 분포에서 나왔는지도 검정이 가능함(2-sample)
<ul>
<li><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/ks-test.png#center"
         alt="이미지 출처" width="370"/> <figcaption>
            <p><a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">이미지 출처</a></p>
        </figcaption>
</figure>
</li>
</ul>
</li>
<li>누적분포함수를 그림으로 그려보면 저 검은색 선인 둘 사이의 거리 D를 통계량으로 테스트함
<ul>
<li>$D_{n,m} = \sup \mid F_{1,n}(x) - F_{2,m}(x) \mid$
<ul>
<li>쉽게 쓰면 그냥 두 누적분포의 최대 차이라는 뜻</li>
</ul>
</li>
<li>영가설은 두 데이터의 분포 간 차이가 없다 (p값이 유의수준 이하일 경우 기각되어 차이가 있다)</li>
</ul>
</li>
<li><code>from scipy.stats import ks_2samp</code> 로 쓸 수 있음</li>
</ul>
</li>
<li><strong>PSI (population stability Index)</strong>
<ul>
<li>$\text{PSI} = \sum((\text{Tested} - \text{Reference}) \times \ln (\frac{\text{Tested}}{\text{Reference}}))$
<ul>
<li>간단한 예시 - 지난주에는 페퍼로니 피자 주문 고객이 전체의 60% 였는데 이번주는 30% 라고 한다면 위 공식에 tested = 30%, reference = 60%로 계산해볼 수 있고 이걸 모든 메뉴에 대해 계산해서 합하면 됨</li>
<li><figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/pis.png#center"
         alt="이미지 출처" width="480"/> <figcaption>
            <p><a href="https://mwburke.github.io/data%20science/2018/04/29/population-stability-index.html">이미지 출처</a></p>
        </figcaption>
</figure>
</li>
</ul>
</li>
<li>카테고리컬한 분포 또는 bin으로 나눈 데이터에 쓰기 편한 지표고 구현도 그냥 하면 될 듯. 다음과 같이 알려진 공식도 있음
<ul>
<li>$\text{PSI} &lt; 0.1$ : 변화 없다</li>
<li>$\text{PSI} &lt; 0.2$ : 약간 변화했다</li>
<li>$\text{PSI} \ge 0.2$ : 심하다 너 경고</li>
</ul>
</li>
</ul>
</li>
<li><strong>Jensen-Shannon Diveregence (JS Divergence)</strong>
<ul>
<li>Kullback-Leibler Divergence (KL Divergence)의 대칭 버전
<ul>
<li>KL Divergence의 아이디어는 한 분포를 다른 분포로 근사할 경우에 얼마나 정보 손실이 발생하느냐? (즉 두 분포가 매우 비슷하다면 손실이 별로 없을 것이고, 다르다면 많이 발생할 것이고)
<ul>
<li>$D_{KL}(p\mid q) = \sum {p(x_i)\cdot (\log p(x_i)-\log q(x_i))}$</li>
<li>두 분포 차이에 대한 기대값</li>
<li>이걸 쪼개면 <code>p 입장에서 q에 대한 크로스 엔트로피 - p의 엔트로피</code></li>
</ul>
</li>
<li>다만 $D_{KL}$ 함수는 거리 함수로 볼 수 없는데, 대칭이 아니어서 =  A와 B 의 아웃풋과 B와 A의 아웃풋이 달라서 (A를 B로 근사하느냐 B를 A로 근사하느냐)</li>
</ul>
</li>
<li>JSD는 다음과 같이 KLD를 양쪽으로(각 분포를 두 분포의 평균으로 근사) 구한 뒤 평균내서 하나의 값으로 만들어준 것
<ul>
<li>$\text{JSD}(p,q) = \frac{1}{2}D_{KL}(p \mid \frac{p+q}{2}) + \frac{1}{2}D_{KL}(q \mid \frac{p+q}{2})$</li>
</ul>
</li>
<li><code>rom scipy.spatial.distance import jensenshannon</code> 로 쓸 수 있음</li>
</ul>
</li>
</ul>
<p>다만 이런 단변량적 시야에는 한계가 몇 가지 있습니다.</p>
<ul>
<li>피쳐가 엄-청 많다면 계속 이걸 하나하나 비교하는 로직을 돌리는 게 낭비 아닐까?</li>
<li>상관관계가 높은 변수들은 한꺼번에 drift될 수 있는데 이게 최종적인 drift 점수에 redundant하게 반영되지 않을까?</li>
<li>다변량적으로(변수가 상호작용하여) 발생하는 drift는 놓치지 않을까?</li>
</ul>
<br>
<h3 id="모델의-오차를-모니터링하자">모델의 오차를 모니터링하자<a hidden class="anchor" aria-hidden="true" href="#모델의-오차를-모니터링하자">#</a></h3>
<p>단변량 접근 말고 통째로 모델 단위로 접근하는 방법을 생각해 봅시다. 모델 학습에 비용이 크게 들지 않는 상황이라면 비교 대상인 두 개의 데이터를 놓고, 따로 모델을 학습시켜서 얼마나 두 개의 모델이 동의하지 않는지(성능이든 피쳐 중요도든)를 수치화해볼 수 있습니다. 하지만 모델 재학습을 최대한 효율적으로 하려고 drift를 사전에 발견하려는 게 아닌가? 싶으니 이건 그렇게 좋은 방법이 아닐 수도 있겠어요.</p>
<p>아니면 시간의 흐름에 따라 모델의 틀림 자체를 모니터링할 수도 있겠죠. 다음 방법들은 <a href="https://scikit-multiflow.readthedocs.io/en/stable/">scikit-multiflow</a> 로 쉽게 써볼 수 있습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/monitoring-error.png#center"
         alt="오차 모니터링 예시 - 이미지 출처" width="550"/> <figcaption>
            <p>오차 모니터링 예시 - <a href="https://www.aporia.com/learn/data-drift/concept-drift-detection-methods/">이미지 출처</a></p>
        </figcaption>
</figure>

<ul>
<li><strong>DDM (Drift Detection Method)</strong>
<ul>
<li>모델이 틀린다/틀리지 않는다를 binomial 변수로 봄
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%9D%B4%ED%95%AD_%EB%B6%84%ED%8F%AC">이항분포</a>를 생각해보자 - $n$번 맞힐 때 독립적으로 $p$의 확률로 틀리거나, 틀리지 않는</li>
<li>$p_t$ : 테스트 시점의 오차율(error rate)</li>
</ul>
</li>
<li>즉 틀림의 기댓값과 편차를 이항분포의 공식에 따라 정의할 수 있다는 뜻
<ul>
<li>$\mu = np_t$</li>
<li>$\sigma = \sqrt{\frac{p_t(1-p_t)}{n}}$</li>
</ul>
</li>
<li>그러면 다음과 같이 <code>지금까지 기록된 오차율 최소값 + 그때 k*편차</code>와 비교했을 때 <code>테스트 시점의 오차율 + 편차</code>가 커져버릴 때 알람을 주는 임계값 설정이 가능
<ul>
<li>경고: $p_t + \sigma_t \ge p_{min} + 2\sigma_{min}$</li>
<li>찐 알람: $p_t + \sigma_t \ge p_{min} + 3\sigma_{min}$</li>
</ul>
</li>
</ul>
</li>
<li><strong>EDDM (Early Drift Detection Method)</strong>
<ul>
<li>접근은 DDM과 유사하나 DDM에 비해 점진적인 drift를 더 잘 잡아낼 수 있다고 함</li>
<li>알람을 주는 기준은 <code>테스트 오차율+그때 2*편차</code>가 <code>오차율 최고값+그때 2*편차</code>와 매우 가까워질 때
<ul>
<li>경고: $\frac{p_t + 2\sigma_t}{p_{max}+2\sigma_{max}}&lt; \alpha$</li>
<li>찐 알람: $\frac{p_t + 2\sigma_t}{p_{max}+2\sigma_{max}}&lt; \beta$
<ul>
<li>$\alpha$, $\beta$ 는 사용자가 정하는 임계치고, 보통 $\alpha$ 0.95, $\beta$  0.9가 보통 디폴트
<ul>
<li>(모든 임계치가 그렇듯 빠르게 drift를 알리고 어느 정도의 false alarm을 감수할 것이냐의 trade-off는 당연히 존재함)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>PHT (Page-Hinkley Test)</strong>
<ul>
<li>기본적으로 지금 값이 이전 값들에서 현저하게 떨어진 값일 경우 알람을 주는 로직
<ul>
<li>단방향(커지는 것만 체크)이지만, 모델 drift를 발견하는 목적으로 오차가 커지는 걸 탐지하는 데 이 테스트를 사용한다면 굳이 양방향일 필요 없을 듯</li>
</ul>
</li>
<li>CUSUM Test에 기반
<ul>
<li>$g_0 = 0$ 이고, $g_t =$ $\max(0, g_{t-1} + (z_t -v))$
<ul>
<li>$g$는 모델의 아웃풋(예를 들어 오차)를 뜻함</li>
<li>$z$는 지금까지 시퀀스를 기반으로 계산된 기대값, 편차를 사용한 표준화값 ($z =(x-\mu)/\sigma$)</li>
<li>$v$는 설정되어야 하는 파라미터인데, 보통 발견해야 하는 수준의 변화의 1/2 정도를 설정한다고 함 (단 표준편차 단위임을 유의)</li>
</ul>
</li>
<li>$g_t &gt; h$이면 알람을 주고 $g_t=0$ 으로 리셋한다!
<ul>
<li>이때 $h$는 설정해야 하는 임계치 파라미터인데, 보통 용인 가능한 false alarm 비율이 $\delta$ 라고 치면 $\ln(1/\delta)$ 로 설정한다고 함</li>
</ul>
</li>
</ul>
</li>
<li>CUSUM은 memoryless하므로(직전 값만 고려) 이를 보완한 것이 PH Test
<ul>
<li>$g_0 = 0$ 이고, $g_t =$ $g_{t-1} + (z_t -v)$, $G_t = \min(g_t, G_{t-1})$
<ul>
<li>$G_t$는 $t$까지 가장 작은 값이 되도록 설정하므로 전체 앞선 시퀀스를 다 고려할 수 있음</li>
</ul>
</li>
<li>$g_t-G_t &gt; h$ 이면 알람을 주고 $g_t = 0$으로 리셋한다!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>다만, <strong>이렇게 모델 단위로 drift를 발견해도, 결국 뭐가 어떻게 문제인지 알아내고 싶다면 각각의 피쳐로 drill down해서 보고 분포의 차이를 명확히 검증해 봐야 하는 경우</strong>가 많을 것 같다는 생각도 드네요.</p>
<br>
<h3 id="차원-축소-후-데이터를-복구해보자">차원 축소 후 데이터를 복구해보자<a hidden class="anchor" aria-hidden="true" href="#차원-축소-후-데이터를-복구해보자">#</a></h3>
<p>또다른 아이디어로는 데이터셋을 PCA 등으로 차원 축소한 다음 복구를 해볼 수도 있습니다. 데이터가 어떻게든 많이 바뀌었다면(PCA가 배운 분산의 형태에서 많이 떨어지게 되었다면) 복구 데이터의 오차가 커질 것이라고 가정하여, 원래 데이터포인트와 복구된 데이터 간의 유클리디언 거리를 drift 점수로 쓰는 것입니다.</p>
<p>모델 성능 예측과 모니터링에 쓰이는 <a href="https://github.com/NannyML/nannyml">NannyML</a> 패키지 공식 문서에 PCA를 사용한 방법으로 다변량 drift를 발견한 예시가 있어서 가져와봤습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/butterfly-scatterplot.png#center" width="480"/> 
</figure>

<p>별로 현실적인 예시는 아니지만 이런 식으로 두 개의 피쳐의 관계가 휙 돌아가(?) 버렸다면 분명 drift가 일어난 건 맞는데, 위와 우측에 그려진 각각의 단변량 분포를 보면 각각의 피쳐 내에서는 분포가 바뀐 것처럼 보이지가 않습니다. 이럴 때 앞서 언급한 PCA 방법을 쓰면, 다음과 같이 복구 오차가 증가하는 것을 볼 수 있습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/data-drift-detection/butterfly-multivariate-drift.png#center" width="480"/> 
</figure>

<br>
<hr>
<h2 id="참고한-글들">참고한 글들<a hidden class="anchor" aria-hidden="true" href="#참고한-글들">#</a></h2>
<ul>
<li><a href="https://nimblebox.ai/blog/machine-learning-model-drift">Model Drift in Machine Learning: How to Detect and Avoid It</a></li>
<li><a href="https://superwise.ai/blog/everything-you-need-to-know-about-drift-in-machine-learning/">Everything you need to know about drift in machine learning</a></li>
<li><a href="https://ai-infrastructure.org/8-concept-drift-detection-methods/">8 Concept Drift Detection Methods</a></li>
<li><a href="https://www.iguazio.com/blog/concept-drift-deep-dive-how-to-build-a-drift-aware-ml-system/">Concept Drift Deep Dive: How to Build a Drift-Aware ML System</a></li>
<li><a href="https://nannyml.readthedocs.io/en/stable/tutorials/detecting_data_drift/multivariate_drift_detection.html">Multivariate Data Drift Detection</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sliceofdata.app/tags/ai-ml/">AI-ML</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Data Drift를 발견하는 법 on x"
            href="https://x.com/intent/tweet/?text=Data%20Drift%eb%a5%bc%20%eb%b0%9c%ea%b2%ac%ed%95%98%eb%8a%94%20%eb%b2%95&amp;url=https%3a%2f%2fsliceofdata.app%2fposts%2fdata-drift-detection%2f&amp;hashtags=AI-ML">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Data Drift를 발견하는 법 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsliceofdata.app%2fposts%2fdata-drift-detection%2f&amp;title=Data%20Drift%eb%a5%bc%20%eb%b0%9c%ea%b2%ac%ed%95%98%eb%8a%94%20%eb%b2%95&amp;summary=Data%20Drift%eb%a5%bc%20%eb%b0%9c%ea%b2%ac%ed%95%98%eb%8a%94%20%eb%b2%95&amp;source=https%3a%2f%2fsliceofdata.app%2fposts%2fdata-drift-detection%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
<div class="container_disqus">
    <script src="https://giscus.app/client.js"
        data-repo="pizzathiefz/sliceofdata"
        data-repo-id="R_kgDOPsr6oQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOPsr6oc4CvOfW"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme=""
        data-lang="en"
        crossorigin="anonymous"
        async>
    </script>
</div>
<script>
    
    function getCurrentTheme() {
        
        let storedTheme = localStorage.getItem('pref-theme');
        if (storedTheme) {
            return storedTheme;
        }
        
        
        if (document.body.classList.contains('dark')) {
            return 'dark';
        }
        
        
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        
        return 'light';
    }
    
    
    function setGiscusTheme() {
        let currentTheme = getCurrentTheme();
        let giscusTheme = currentTheme === 'dark' ? 'noborder_dark' : 'noborder_light';
        
        
        let giscusScript = document.querySelector("div.container_disqus > script");
        if (giscusScript) {
            giscusScript.setAttribute('data-theme', giscusTheme);
        }
        
        return giscusTheme;
    }
    
    
    setGiscusTheme();
    
    
    document.addEventListener('DOMContentLoaded', function() {
        let themeToggle = document.querySelector('#theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                setTimeout(() => {
                    let newTheme = getCurrentTheme();
                    let newGiscusTheme = newTheme === 'dark' ? 'noborder_dark' : 'noborder_light';
                    
                    let giscusFrame = document.querySelector('iframe.giscus-frame');
                    if (giscusFrame) {
                        giscusFrame.contentWindow.postMessage({
                            giscus: {
                                setConfig: {
                                    theme: newGiscusTheme
                                }
                            }
                        }, 'https://giscus.app');
                    }
                }, 100);
            });
        }
    });
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://sliceofdata.app/">sliceofdata</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
