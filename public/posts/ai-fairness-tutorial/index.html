<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>차별하지 않는 분류 모델 만들기 | sliceofdata</title>
<meta name="keywords" content="ai fairness">
<meta name="description" content="차별은 기계한테 당해도 서러운 법">
<meta name="author" content="pizzathief">
<link rel="canonical" href="https://sliceofdata.app/posts/ai-fairness-tutorial/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.27cad2a1c5348b9448235a32de472a54bfb4b517f58e15427dc5a1a01bf486da.css" integrity="sha256-J8rSocU0i5RII1oy3kcqVL&#43;0tRf1jhVCfcWhoBv0hto=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sliceofdata.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sliceofdata.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sliceofdata.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sliceofdata.app/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://sliceofdata.app/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://sliceofdata.app/posts/ai-fairness-tutorial/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {
  delimiters: [
    {left: '$$', right: '$$', display: true},
    {left: '$', right: '$', display: false},
    {left: '\\(', right: '\\)', display: false},
    {left: '\\[', right: '\\]', display: true}
  ],
  throwOnError: false
});"></script>
<meta property="og:url" content="https://sliceofdata.app/posts/ai-fairness-tutorial/">
  <meta property="og:site_name" content="sliceofdata">
  <meta property="og:title" content="차별하지 않는 분류 모델 만들기">
  <meta property="og:description" content="차별은 기계한테 당해도 서러운 법">
  <meta property="og:locale" content="ko-KR">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-08-22T17:08:27+09:00">
    <meta property="article:modified_time" content="2021-08-22T17:08:27+09:00">
    <meta property="article:tag" content="Fairness">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="차별하지 않는 분류 모델 만들기">
<meta name="twitter:description" content="차별은 기계한테 당해도 서러운 법">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sliceofdata.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "차별하지 않는 분류 모델 만들기",
      "item": "https://sliceofdata.app/posts/ai-fairness-tutorial/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "차별하지 않는 분류 모델 만들기",
  "name": "차별하지 않는 분류 모델 만들기",
  "description": "차별은 기계한테 당해도 서러운 법",
  "keywords": [
    "ai fairness"
  ],
  "articleBody": "공정한 모델은 왜 필요할까? COMPAS라는 소프트웨어는 각 피고에 대해 성별, 나이, 인종, 전과, 사는 지역, 사회경제적 수준 등 다양한 데이터를 기반으로 이 사람이 다시 범행을 저지를지 아닐지를 예측하여, 재판 과정에서 형량이나 가석방 여부에 대한 결정을 보조해 줍니다. 머신 러닝 분류 모델을 개인의 인생에 큰 영향을 미치는 의사결정 수단으로 사용하는 전형적인 예시라고 할 수 있겠습니다.\n알고리즘이 재범하지 않을 것으로 예측했으나 이후 3번이나 동일 범죄로 체포된 경우, 높은 위험으로 예측했으나 재범하지 않은 경우 출처\n미국의 여러 주에서 실제로 법정에서 활용되던 이 소프트웨어는 2016년에 일관되게 흑인 피고들에게 불리한 결론을 내 온 것이 프로퍼블리카지에 의해 폭로되어 비난 받게 됩니다. 그리고 지금처럼 위험한 AI의 예시로 두고두고 쓰이게 되었죠. 폭로 기사에 따르면 당시 COMPAS는 피고가 흑인일 경우 이후 그 사람이 실제로 재범하지 않았음에도 판결 시 재범 위험이 높은 것으로 예측한 경우가 많았는데, 이 FPR(거짓 양성 비율)이 무려 45%에 달했다고 합니다. 백인의 경우 반대 케이스인, 낮은 위험으로 예측했으나 다시 범죄를 저지른 경우가 그만큼 많았고요.\n왜 이런 현상(Bias)이 발생할까요? 그건 데이터가 불균형하기 때문일 수도, 혹은 실제로 사회에 존재하는 편향이 데이터 자체에 포함되어 있기 때문일 수도 있습니다. 머신러닝 모델의 편향의 근원에 대해서는 또다른 아주 많은 얘기가 따라올 수 있어 이번 글에서는 자세히 다루지 않겠습니다.\n위험은 이 특정 분야에만 있는 게 아니며, 수치형 데이터에 기반한 분류기에만 한정된 이슈도 아닙니다. 2015년에 구글 포토가 흑인의 얼굴을 고릴라로 분류해서 구글이 사과하는 사건이 있었고, 그 이후로도 안면인식 모델이 소수 인종에 대해서만 유달리 낮은 정확도를 보인다는 문제제기는 지속되고 있습니다. 2018년에는 아마존이 채용 시 사용하는 이력서 스크리닝 알고리즘을 개발했으나, “여성 체스 클럽”처럼 지원자가 여성임을 암시하는 단어가 포함되기만 해도 낮은 점수를 주어 개발을 중단했다고 알려졌습니다.\n구글에 Racist AI를 검색하면 나오는 수많은 사진 중 하나 - 저화질 이미지를 복구해주는 PULSE(StyleGAN 기반)가 누가 봐도 미국의 첫 흑인 대통령의 얼굴인 사진을 받아 백인 남자의 얼굴을 내놓았다 출처\n모델의 성능이 좋고 얼마나 놀라운 일을 해내는지와는 별개로 그 결과물을 우리 사회에서 사용하려면 특정 인구 집단에 대해 차별적이지 않아야 합니다. 이 부분에 대한 사회적인 신뢰와 합의가 보장되지 않는다면, 아무리 날고 기는 모델이라도 신용 평가, 정책, 치안, 입시, 채용, 의료 분야에서 실제 중요한 결정을 내리는 데 쓰기는 어렵겠죠. 아무도 내 실제 능력과 무관하게 변경할 수 없는 어떤 특성 때문에 대출을 받지 못하거나, 좋은 채용 기회를 놓치거나, 심지어 불필요한 옥살이를 하고 싶지는 않을 테니까요. (그리고 현재까지의 사례들을 보면 백인 남성을 제외한 대부분의 인구 집단은 그런 걱정에서 자유롭지 못할 것 같네요.)\n학계에서도 최근 5년 간 상당히 주목 받는 주제 중 하나로, ML Fairness를 다룬 논문들의 수는 해마다 증가하고 있다. 이 차트가 2020년 중간에 그려졌기 때문에 2020년 값은 빼고 보자 출처\n공정하게 대출을 승인해주는 분류 모델을 만들어보자 (f. AIF 360) 공정한 모델을 어떻게 얻을 수 있을까요? 잠시 법정에서 은행으로 영역을 이동해 보겠습니다. 우리는 대출을 신청한 사람들의 각종 개인 정보와 은행에서 실제로 빌려주었는지 여부를 포함한 데이터를 가지고 있습니다. 이 데이터를 통해 새로운 신청자에게 빌려줄까 말까를 스스로 판단하는 분류기를 학습시키려고 합니다.\n사용 데이터와 Baseline 모델 캐글에서 받아왔습니다.\n대출을 신청한 개인 $i$의 각종 특성들: $X_i \\in \\mathbb{R}^n$ 성별, 결혼 여부, 부양가족 수, 교육 수준(Graduate / Not Graduate ), 자영업 여부, 신용 점수 과락 통과 여부, 지역(Urban / Rural / Semiurban ), 본인 수입, 공동 신청자의 수입, 신청 금액 예측하고자 하는 값: 실제 대출의 승인 여부 $Y_i = { 0,1 }$ 모델, 결정 규칙 $d$ : $d(X_i) = 1$ 이면 빌려주자. 대부분의 공정성 논의에서는 모델이 차별하지 않고자 하는, 즉 상식 상 혹은 특정 맥락에서 만약 차별이 있다면 한 집단이 다른 집단에 비해 이득을 볼 것으로 생각되는 어떤 변수를 선 지정하게 됩니다. 제가 위에서 언급했던 사건들에서는 인종이나 성별이 해당되겠죠. 문헌에서는 주로 이를 민감한 속성(sensitive attributes) 혹은 보호 속성(protected attributes)라는 이름으로 부르는데요. 우리는 전자를 골라 아래처럼 표기하고, 교육 수준이라는 변수를 선택해보겠습니다.\n차별하지 않고자 하는 민감한 속성: $X_s \\subset X$ 교육 수준(고등학교 졸업 여부) 오늘 함께 사용할 AI Fiarness 360 (AIF 360)은 머신러닝 모델의 편향을 테스트하고 완화하는 다양한 테크닉들을 포함한 오픈소스 툴킷으로, 파이썬과 R을 둘 다 지원합니다.\n저는 파이썬을 사용하도록 하겠습니다. 우선 보통 많이 사용하는 Pandas 데이터프레임 형태에서 다음과 같이 AIF 360이 잘 받아먹을 수 있는 StandardDataset으로 변경할 것인데, 거의 유사하지만 공정성 판단에 필요한 정보(민감한 속성과 이득을 보는 집단, 그리고 예측 라벨 중에 무엇이 이득인지)을 지정해준 버전의 데이터프레임이라고 생각하면 됩니다. 이 데이터셋을 가지고 모델 학습도 하고(Scikit-learn과 호환성이 꽤 괜찮습니다) AIF360 이 제공하는 각종 테스트와 완화 기법을 적용할 겁니다.\n1 2 3 4 5 data = StandardDataset(df, label_name='Loan_Status', favorable_classes=[1], protected_attribute_names = ['Education'], privileged_classes=[0]) #df는 아래 모델학습 단계 중 최소한의 전처리를 마친 Pandas dataframe favorable_classes : 예측 라벨인 Loan_Status 중 무엇이 이득인지 (여기서는 1=대출 승인) protected_attribute_names : 미리 정한 민감한 속성 (여기서는 교육수준) privileged_classes : 민감한 속성 변수의 라벨 중 중 차별이 있다면 이득을 볼 것으로 생각되는 집단 (여기서는 0=고등학교 졸업자) 우선 아무것도 하지 않고 모델 학습을 진행해 보겠습니다.\n최소한의 전처리 결측치 최빈값 또는 평균으로 imputation 카테고리컬 변수(성별, 결혼여부, 교육, 자영업 여부, 신용점수의 과락 통과 여부, 지역)의 인코딩 수치형 변수(본인 수입, 공동 신청자의 수입, 신청 금액, 부양가족 수)의 스케일링 학습, 테스트 셋 7:3으로 분리 1 2 #StandardDataset은 바로 split 메서드를 지원, sklearn과 달리 트레이닝 셋의 비율을 입력한다. train, test = data.split([0.7], shuffle=True) 모델 학습 RandomForestClassifier 사용 1 2 3 4 5 6 7 8 from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score base_rf = RandomForestClassifier().fit(train.features, train.labels.ravel(), sample_weight=train.instance_weights) base_rf_pred = base_rf.predict(test.features) print('Accuracy Score: ', accuracy_score(base_rf_pred, test.labels.ravel())) print('F1 Score: ', f1_score(base_rf_pred, test.labels.ravel())) 데이터 크기가 600개 남짓인 데다 아무것도 안 한 것 치고는 뭐 그럭저럭인 것 같습니다. 성능을 높이는 건 이 글의 주안점이 아니니 넘어갑시다.\n그 다음에 가장 먼저 해야 할 일은 과연 우리의 분류기가 공정한지 테스트부터 해보는 것입니다. 문제가 없는데 해결할 수는 없는 법, 의외로 문제가 없을 수도 있지 않을까요?\n‘공정한’ 게 뭔데? 테스트를 해보자니 당연히 공정함이 대체 뭔데? 라는 의문이 먼저 들 것입니다. 단순히 백인을 10명 가석방시키는 동안 소수인종을 10명 가석방시키면 공정할까요? 입사 점수가 동일하면서 불합격한 인원의 비율이 남녀 간 차이가 없으면 공정할까요? 이런 질문에 일반적인 답을 하려면 왠지 엄청난 철학 공부가 필요할 것 같은 기분이 드는데요, 제가 그쪽의 능력은 전혀 없고요. 아마 머신러닝 모델도 아직 그럴 능력은 없을 겁니다. 모델이 이해하려면 수식으로 쓰인 정의가 필요하죠. 다만 정의가 수식이라는 것보다 더 중요한 사실은, 정의가 여러 가지라는 것입니다.\n의외의 사실은 아니겠지만 무엇이 공정한 모델이냐는 질문에는 여러 가지의 답이 있고 그에 따른 여러 가지의 정의와 여러 가지의 수식이 있습니다. 이 분야가 처음 주목받기 시작한 이래로 여러 학자들이 너도나도 각자 자신이 생각하는 공정함의 정의를 들고 왔고, 심지어 어떤 논문은 남이 들고 온 정의들의 양립 불가능성(얘가 주장한 A랑 쟤가 주장한 B랑 동시에 만족하는 건 수학적으로 불가능해!)을 증명하기도 했습니다.\n결국 완벽하게 합의된 정의는 없습니다. 만약 모델을 만들고 사용하는 누군가가 공정한 모델을 원한다면 그 모델의 사회적 활용의 방향성과 본인의 주관에 따라 적절한 정의를 선택해야 하는 상황이 되겠습니다. 이제 제가 왜 위 소제목에서 ‘공정한’에 따옴표를 쳤는지 알겠죠(공정함은 당신 마음 속에 🌟).\nAIF360의 ClassificationMetric 클래스를 이용하면 이진분류 모델을 받아 기본적인 분류모델의 성능 관련된 수치들과 각종 공정성 관련 평가지표들을 쉽게 알아볼 수 있습니다. (문서)\n1 2 3 4 5 6 7 8 9 10 11 12 pgroup = [ {'Education':data.privileged_protected_attributes[0]} ] upgroup = [ {'Education':data.unprivileged_protected_attributes[0]} ] test_pred = test.copy() test_pred.labels = base_rf_pred metrics = ClassificationMetric(dataset = test, classified_dataset = test_pred, privileged_groups = pgroup, unprivileged_groups = upgroup ) #(un)previleged_groups에는 각 민감한 속성:이익/불이익 집단을 딕셔너리화하여 리스트로 합쳐서 넣어주면 된다 그 중에서 우리는 다음 4가지의 지표를 살펴보겠습니다. 이때 앞서 언급한 $X$, $Y$, $d(X)=\\hat Y,$ $X_S \\subset X$ 의 노테이션은 그대로 사용합니다. $X_S=0$ 이 고등학교 졸업자, $Y=1$이 대출 승인입니다.\nStatistical Parity Difference\n양성 예측 비율(Positive rate)이 집단 간 동일하면 공정한 모델이라고 본다. 즉, 고등학교 졸업자 중 갚을 것이라고 예측한 사람의 비율과 비졸업자 중 갚을 것이라고 예측한 사람의 비율이 같으면 된다.\n불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 작은 (음수) 값이며, 0이 이상적\n$$ P_{X_S=0}[d(X)=1] - P_{X_S=1}[d(X)=1] $$\nError Rate Difference\n정확도(Accuracy)이 집단 간 동일하면 공정한 모델이라고 본다. 고등학교 졸업자에 대한 예측 정확도와 비졸업자에 대한 예측 정확도가 동일하면 된다.\n불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 큰 값이며, 0이 이상적\n$$ P_{X_S=1}[d(X) \\neq Y] - P_{X_S=1}[d(X) \\neq Y], Y \\in {0,1} $$\nFalse Positive Rate Difference\n거짓 양성 비율(False Positive Rate)이 집단 간 동일하면, 즉 예측과 민감한 속성이 라벨에 대해 조건부 독립이면 공정한 모델이라고 본다.\n불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 큰 값이며, 0이 이상적\n$$ P_{X_S=1}[d(X) =1 \\vert Y=0] - P_{X_S=0}[d(X)=1 \\vert Y=0] $$\nFalse Discovery Rate Difference\n거짓 발견 비율(False Discovery Rate)이 집단 간 동일하면, 즉 모델의 라벨과 민감한 속성이 예측이 주어졌을 때 조건부 독립이면 공정한 모델이라고 본다. 불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 큰 값이며, 0이 이상적 $$ P_{X_S = 0} [Y=0 \\vert d(X) = 1] - P_{X_S =1} [Y=0 \\vert d(X)=1 ] $$\n이 외에도 많은 정의들이 있지만, 정답은 뭐다? 각자의 마음속에 있다… 다만 어떤 정의들의 한계는 명확히 보입니다. 예를 들어 양성 비율만 보는 경우, $Y$와 $X_S$의 상관을 완전히 무시하게 되죠. 또 만약 어떤 집단에서는 진짜 능력 있는 사람만 1로 예측하고 다른 집단에서는 랜덤하게 아무나 1로 예측한다면 이는 상식적으로 불공정하지만 비율만 같으면 이 기준에서는 공정하게 보일 것입니다. 반면 정확도만 본다면, 한 집단의 FPR과 다른 집단의 FNR 간의 trade가 발생할 수 있습니다. 어떤 경우 한 집단의 능력 있는 사람을 거절하는 비율을 높이고, 다른 집단의 능력 없는 사람에게 대출을 해주는 방식으로 정확도가 동일하게 유지될 수 있는 위험이 있죠.\n어쨌든 우리의 막 만든 모델에 대해 4가지 값을 확인해 보면 이렇습니다.\n1 2 3 4 5 print('Statistical Parity Difference: ', -metrics.statistical_parity_difference()) print('Error Rate Difference: ', metrics.error_rate_difference()) print('False Positive Rate Difference: ', metrics.false_positive_rate_difference()) print('False Discovery Rate Difference: ', metrics.false_discovery_rate_difference()) metrics의 모든 수치는 일정하게 (비졸업자 수치 - 졸업자 수치)라 다른 건(Error, FPR, FDR) 다 높을수록 불공정한 거지만 statistical parity만 반대라서 헷갈리지 않도록 부호를 바꿔, 다른 메트릭과 동일하게 클수록 불공정하도록 했습니다.\n단순 양성 비율만 보는 지표를 제외한 나머지 지표들에서는 우리의 베이스라인 모델이 고등학교를 나온 사람에게 유리한 결정을 내리고 있다는 사실을 알 수 있습니다. 특히 COMPAS 케이스처럼 FPR의 차이가 38%대로 눈에 띕니다.\n신기한 점은 양성 비율만 봤을 때는 고등학교를 졸업하지 않은 사람의 양성 비율이 8% 정도 더 높다는 것입니다. 즉 같은 모델인데도 어떤 지표를 보면 불공정하고 다른 지표를 보면 별 문제 없어 보인다는 것, 그래서 모델을 만들고 데이터를 사용하는 사람의 주관적 결정이 중요하다는 것이 결론이 되기도 하겠습니다.\n어떻게 해결하지? 위의 등장한 정의들은 일종의 메트릭입니다. 그리고 방금 제 모델이 그랬듯 아무런 조치 없이 모델을 훈련시킨다면 아마 공정의 정의를 무엇으로 선택하든 만족하지 못할 확률이 높을 겁니다. 그러면 이제, 이 불공정한 모델을 어떻게 고쳐볼까의 질문으로 넘어가 봅시다.\n공정함의 조건을 만족하지 못하는, 즉 편향이 있는 모델에 대해 편향을 완화(mitigation)시키는 테크닉들은 크게 어떤 단계에서 행하느냐에 따라 전처리, 학습, 사후 처리 이렇게 3가지로 나뉩니다. 요약해 보면 다음과 같습니다.\n전처리를 통한 편향 완화 (Pre-Processing) 모델의 인풋 데이터를 잘 고쳐보자! 데이터를 리샘플링하거나 가중치를 잘 분배해보기 집단 간 클래스 라벨을 뒤집어보기 민감한 특성을 아예 생략해보기 특정 공정함 조건을 만족시키도록 인풋 데이터를 변형시키는 모델 또는 함수를 학습시키기 학습 시 편향 완화 (In-Processing) 모델 학습 방식을 바꿔서 정확도와 공정함을 모두 목표로 하도록 모델을 훈련시켜보자! 적대적 학습을 이용(타겟 데이터를 예측하는 모델 ↔ 그 모델로 민감한 특성을 예측하는 모델, 후자가 민감한 특성을 예측할 수 없도록) Loss function에 공정함 관련 제약 값(constraint) 을 추가하기 사후 처리를 통한 편향 완화 (Post-Processing) 데이터와 모델은 그대로 유지하고, 최종 아웃풋만 잘 조정해보자! 특정 공정함 조건을 만족시키도록 그룹 별로 최종 분류 threshold를 최적화하기 특정 공정함 조건을 만족시키도록 아웃풋 데이터를 변형시키는 모델 또는 함수를 학습시키기 AIF 360은 각 단계별로 여러 가지의 편향 완화 알고리즘을 제공해주고 있습니다. 문서에서 세어봤는데요, 전처리에서 4개, 학습 시 7개, 사후처리 3개가 있네요.\n이 글에서는 각 단계별로 1개씩만 사용해보고 베이스 모델과 성능 및 공정성 지표를 비교해볼 것입니다. 우선 각 기법의 접근방식을 요약하고 코드 및 논문을 함께 달아두겠습니다. 각 방법이 더 궁금하다면 링크된 논문을, 그 외의 다른 기법들이 궁금하다면 AIF 360 문서에서 확인할 수 있습니다.\n[전처리] Reweighing Data preprocessing techniques for classification without discrimination 민감한 속성과 라벨 조합 별로 다르게 가중치를 두어 학습하는데, 차별이 존재하는 방향과 일치하는(일반적인 편견에 부합하는) 데이터는 가중치를 낮게 주고 반대는 높게 준다. 즉 대출을 승인받은 고등학교 비졸업자는 대출을 승인받지 못한 고등학교 비졸업자보다 높은 가중치를 부여하고, 반대로 대출을 승인받지 못한 고등학교 졸업자 데이터에 대출을 승인받은 고등학교 졸업자보다 높은 가중치를 부여한다. 1 2 3 4 5 6 RW = Reweighing(unprivileged_groups=upgroup, privileged_groups=pgroup) rw_train = RW.fit_transform(train) rw_rf = RandomForestClassifier().fit(rw_train.features, rw_train.labels.ravel(), sample_weight = rw_train.instance_weights) rw_test = RW.transform(test) [학습] Adversarial Debiasing Mitigating Unwanted Biases with Adversarial Learning 예측변수(대출 승인 여부)를 예측하는 모델과 민감한 속성(교육 수준)을 예측하는 적대적 모델을 만들어 전자의 성능을 최대화, 후자의 성능을 최소화하도록 학습한다. 즉 이 방식의 목표는 그 예측 결과만 보고 민감한 속성 여부를 예측하기 어려운 모델을 만드는 것. 1 2 3 4 5 6 7 8 9 10 sess = tf.Session() tf.disable_eager_execution() ad = AdversarialDebiasing(privileged_groups = pgroup, unprivileged_groups = upgroup, scope_name='debiased_classifier', num_epochs=10, debias=True, sess=sess) ad.fit(train) ad_pred = ad.predict(test) [사후처리] Reject Option Classification Decision Theory for Discrimination-Aware Classification 모델은 예측 결과에 대해 확신이 있을 때가 아니라 헷갈릴 때 차별을 하게 된다고 본다. 예를 들면 결정 경계(decision boundary)가 0.5일 때, 어떤 데이터가 0.1이나 0.9이면 문제 없이 예측하지만 0.49나 0.51이라면 예측 불확실성이 높아지는데, 그래도 최대한 예측을 잘 하기 위해 일반적으로 이득을 보는 집단에게 더 좋은 결과(ex. 대출 승인)을 주게 된다는 것이다. 사람도 정확한 정보만으로 판단하기 애매한 케이스가 주어지면 편견에 따라 행동할 수 있다는 점을 생각하면 오..그러네..🤔? 하게 되는 아이디어. 따라서 이 방법은 학습이 완료된 모델의 예측 데이터를 가지고 결정 경계 근처의, 불확실성이 가장 높은 데이터만 고등학교 졸업자는 거절, 비졸업자는 승인으로 바꿔준다. 1 2 3 4 5 ROC = RejectOptionClassification(privileged_groups = pgroup, unprivileged_groups = upgroup) ROC = ROC.fit(test, base_test_pred) roc_test_pred = ROC.predict(base_test_pred) 완화 처리의 효과는? 이제 제일 처음 학습시켰던 베이스 모델과 저 3가지 테크닉을 각자 적용한 추가 3개의 모델을 비교해볼 것입니다.\n이전에 확인했던 4개의 공정성 지표가 얼마나 달라졌는지도 궁금하지만, 일반적으로 편향을 제거하기 위한 조치를 취하면 모델 성능은 떨어질 것 같은데 과연 그럴지도 궁금합니다.\n우선 성능부터 보면, Reweighing 외 다른 2개의 기법은 기존 모델에 비해 성능이 감소했음을 알 수 있습니다. 사실 공정성을 위해 보정하다 보면 성능이 떨어진다는 것은 이 공정성 논의에서 항상 당연한 것처럼 언급이 되었던 사실입니다. 다만 최근에는 trade-off 가 무조건 발생하는 것이 아니며, 항상 정확도와 공정성 간의 이상적인 최적 지점을 찾을 수 있다는 것을 이론적으로 증명하는 논문도 나오고 했더라고요.\n이제 각 공정성 지표의 모델별 차이를 보겠습니다.\n가장 차이가 심각했던 FPR 지표의 경우 3개의 완화 기법 모두 어느 정도 성공적으로 낮추었고, Adversarial Learning이 가장 효과가 좋다. Statistical Parity의 경우는 각 모델 별로 불공정의 방향성이 다른데, 모두 5% 미만대로 큰 수치는 아니라 의미가 없어 보인다. Error Rate이나 FDR의 경우, 일부 모델은 오히려 불공정 정도가 베이스 모델에 비해 심화되었다. 모델 기준으로 종합해보면 Adversarial Learning이 모든 지표를 상당 수준 이하 감소시켰으나 성능 또한 가장 큰 폭으로 감소한 기법이었다. Reweighing의 경우 성능은 유지되었으나 FPR 외의 다른 지표에서 편향을 완화하지 못했고 오히려 더 증폭하는 영향이 있었다. 여기까지 보았을 때 결론은 어떤 지표를 공정성의 정의로 사용하느냐에 따라 선택할 수 있는 완화 기법도 크게 달라질 수 있다는 것, 그리고 어떤 정의와 모델을 택하든 (최적 포인트를 찾지 못하면) 공정성과 성능 간 trade-off가 존재할 가능성이 있다는 것이 되겠습니다.\n참고한 글들 Fairness Definitions Explained Algorithms for Fair Machine Learning: An Introduction Ethics and AI : how to prevent bias on ML? ",
  "wordCount" : "2351",
  "inLanguage": "ko",
  "datePublished": "2021-08-22T17:08:27+09:00",
  "dateModified": "2021-08-22T17:08:27+09:00",
  "author":{
    "@type": "Person",
    "name": "pizzathief"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sliceofdata.app/posts/ai-fairness-tutorial/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "sliceofdata",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sliceofdata.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sliceofdata.app/" accesskey="h" title="slice.of.data (Alt + H)">
                <img src="https://sliceofdata.app/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">slice.of.data</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://sliceofdata.app/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sliceofdata.app/archives/" title="posts">
                    <span>posts</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/about/" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/subscribe" title="subscribe">
                    <span>subscribe</span>
                </a>
            </li>
            <li>
                <a href="https://pizzathief.pages.dev/" title="notes">
                    <span>notes</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      차별하지 않는 분류 모델 만들기
    </h1>
    <div class="post-meta"><span title='2021-08-22 17:08:27 +0900 KST'>2021-08-22</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;pizzathief&nbsp;|&nbsp;<a href="https://github.com/pizzathiefz/sliceofdata/blob/main/content/posts/ai-fairness-tutorial/index.ko.md" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#공정한-모델은-왜-필요할까">공정한 모델은 왜 필요할까?</a></li>
    <li><a href="#공정하게-대출을-승인해주는-분류-모델을-만들어보자-f-aif-360">공정하게 대출을 승인해주는 분류 모델을 만들어보자 (f. AIF 360)</a>
      <ul>
        <li><a href="#사용-데이터와-baseline-모델">사용 데이터와 Baseline 모델</a></li>
      </ul>
    </li>
    <li><a href="#공정한-게-뭔데">‘공정한’ 게 뭔데?</a></li>
    <li><a href="#어떻게-해결하지">어떻게 해결하지?</a>
      <ul>
        <li><a href="#전처리-reweighing">[전처리] Reweighing</a></li>
        <li><a href="#학습-adversarial-debiasing">[학습] Adversarial Debiasing</a></li>
        <li><a href="#사후처리-reject-option-classification">[사후처리] Reject Option Classification</a></li>
        <li><a href="#완화-처리의-효과는">완화 처리의 효과는?</a></li>
      </ul>
    </li>
    <li><a href="#참고한-글들">참고한 글들</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="공정한-모델은-왜-필요할까">공정한 모델은 왜 필요할까?<a hidden class="anchor" aria-hidden="true" href="#공정한-모델은-왜-필요할까">#</a></h2>
<p>COMPAS라는 소프트웨어는 각 피고에 대해 성별, 나이, 인종, 전과, 사는 지역, 사회경제적 수준 등 다양한 데이터를 기반으로 이 사람이 다시 범행을 저지를지 아닐지를 예측하여, 재판 과정에서 형량이나 가석방 여부에 대한 결정을 보조해 줍니다. <strong>머신 러닝 분류 모델을 개인의 인생에 큰 영향을 미치는 의사결정 수단으로 사용</strong>하는 전형적인 예시라고 할 수 있겠습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/compas.png#center"
         alt="알고리즘이 재범하지 않을 것으로 예측했으나 이후 3번이나 동일 범죄로 체포된 경우, 높은 위험으로 예측했으나 재범하지 않은 경우 출처" width="300"/> <figcaption>
            <p>알고리즘이 재범하지 않을 것으로 예측했으나 이후 3번이나 동일 범죄로 체포된 경우, 높은 위험으로 예측했으나 재범하지 않은 경우 <a href="https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing">출처</a></p>
        </figcaption>
</figure>

<p>미국의 여러 주에서 실제로 법정에서 활용되던 이 소프트웨어는 2016년에 <strong>일관되게 흑인 피고들에게 불리한 결론을 내 온</strong> 것이 프로퍼블리카지에 의해 폭로되어 비난 받게 됩니다. 그리고 지금처럼 위험한 AI의 예시로 두고두고 쓰이게 되었죠. 폭로 기사에 따르면 당시 COMPAS는 피고가 흑인일 경우 이후 그 사람이 실제로 재범하지 않았음에도 판결 시 재범 위험이 높은 것으로 예측한 경우가 많았는데, 이 FPR(거짓 양성 비율)이 무려 45%에 달했다고 합니다. 백인의 경우 반대 케이스인, 낮은 위험으로 예측했으나 다시 범죄를 저지른 경우가 그만큼 많았고요.</p>
<blockquote>
<p>왜 이런 현상(Bias)이 발생할까요? 그건 데이터가 불균형하기 때문일 수도, 혹은 실제로 사회에 존재하는 편향이 데이터 자체에 포함되어 있기 때문일 수도 있습니다. 머신러닝 모델의 편향의 근원에 대해서는 또다른 아주 많은 얘기가 따라올 수 있어 이번 글에서는 자세히 다루지 않겠습니다.</p></blockquote>
<p>위험은 이 특정 분야에만 있는 게 아니며, 수치형 데이터에 기반한 분류기에만 한정된 이슈도 아닙니다. 2015년에 <a href="https://www.bbc.com/news/technology-33347866">구글 포토가 흑인의 얼굴을 고릴라로 분류해서 구글이 사과하는 사건</a>이 있었고, 그 이후로도 안면인식 모델이 소수 인종에 대해서만 유달리 낮은 정확도를 보인다는 문제제기는 지속되고 있습니다. 2018년에는 아마존이 채용 시 사용하는 이력서 스크리닝 알고리즘을 개발했으나, <a href="https://www.reuters.com/article/us-amazon-com-jobs-automation-insight-idUSKCN1MK08G">“여성 체스 클럽”처럼 지원자가 여성임을 암시하는 단어가 포함되기만 해도 낮은 점수를 주어</a> 개발을 중단했다고 알려졌습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/obama.jpg#center"
         alt="구글에 Racist AI를 검색하면 나오는 수많은 사진 중 하나 - 저화질 이미지를 복구해주는 PULSE(StyleGAN 기반)가 누가 봐도 미국의 첫 흑인 대통령의 얼굴인 사진을 받아 백인 남자의 얼굴을 내놓았다 출처" width="500"/> <figcaption>
            <p>구글에 Racist AI를 검색하면 나오는 수많은 사진 중 하나 - 저화질 이미지를 복구해주는 PULSE(StyleGAN 기반)가 누가 봐도 미국의 첫 흑인 대통령의 얼굴인 사진을 받아 백인 남자의 얼굴을 내놓았다 <a href="https://twitter.com/Chicken3gg/status/1274314622447820801">출처</a></p>
        </figcaption>
</figure>

<p>모델의 성능이 좋고 얼마나 놀라운 일을 해내는지와는 별개로 <strong>그 결과물을 우리 사회에서 사용하려면 특정 인구 집단에 대해 차별적이지 않아야 합니다.</strong> 이 부분에 대한 사회적인 신뢰와 합의가 보장되지 않는다면, 아무리 날고 기는 모델이라도 신용 평가, 정책, 치안, 입시, 채용, 의료 분야에서 실제 중요한 결정을 내리는 데 쓰기는 어렵겠죠. 아무도 내 실제 능력과 무관하게 변경할 수 없는 어떤 특성 때문에 대출을 받지 못하거나, 좋은 채용 기회를 놓치거나, 심지어 불필요한 옥살이를 하고 싶지는 않을 테니까요. (그리고 현재까지의 사례들을 보면 백인 남성을 제외한 대부분의 인구 집단은 그런 걱정에서 자유롭지 못할 것 같네요.)</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/publications.png#center"
         alt="학계에서도 최근 5년 간 상당히 주목 받는 주제 중 하나로, ML Fairness를 다룬 논문들의 수는 해마다 증가하고 있다. 이 차트가 2020년 중간에 그려졌기 때문에 2020년 값은 빼고 보자 출처" width="540"/> <figcaption>
            <p>학계에서도 최근 5년 간 상당히 주목 받는 주제 중 하나로, ML Fairness를 다룬 논문들의 수는 해마다 증가하고 있다. 이 차트가 2020년 중간에 그려졌기 때문에 2020년 값은 빼고 보자 <a href="https://deepai.org/publication/fairness-in-machine-learning-a-survey">출처</a></p>
        </figcaption>
</figure>

<br>
<h2 id="공정하게-대출을-승인해주는-분류-모델을-만들어보자-f-aif-360">공정하게 대출을 승인해주는 분류 모델을 만들어보자 (f. AIF 360)<a hidden class="anchor" aria-hidden="true" href="#공정하게-대출을-승인해주는-분류-모델을-만들어보자-f-aif-360">#</a></h2>
<p>공정한 모델을 어떻게 얻을 수 있을까요? 잠시 법정에서 은행으로 영역을 이동해 보겠습니다. 우리는 대출을 신청한 사람들의 각종 개인 정보와 은행에서 실제로 빌려주었는지 여부를 포함한 데이터를 가지고 있습니다. 이 데이터를 통해 새로운 신청자에게 빌려줄까 말까를 스스로 판단하는 분류기를 학습시키려고 합니다.</p>
<br>
<h3 id="사용-데이터와-baseline-모델">사용 데이터와 Baseline 모델<a hidden class="anchor" aria-hidden="true" href="#사용-데이터와-baseline-모델">#</a></h3>
<p><a href="https://www.kaggle.com/vikasp/loadpred">캐글</a>에서  받아왔습니다.</p>
<ul>
<li>대출을 신청한 개인 $i$의 각종 특성들: $X_i \in \mathbb{R}^n$
<ul>
<li>성별, 결혼 여부, 부양가족 수, 교육 수준(<code>Graduate</code> / <code>Not Graduate</code> ), 자영업 여부, 신용 점수 과락 통과 여부, 지역(<code>Urban</code> / <code>Rural</code> / <code>Semiurban</code> ), 본인 수입, 공동 신청자의 수입, 신청 금액</li>
</ul>
</li>
<li>예측하고자 하는 값: 실제 대출의 승인 여부 $Y_i = { 0,1 }$</li>
<li>모델, 결정 규칙 $d$  : $d(X_i) = 1$ 이면 빌려주자.</li>
</ul>
<p>대부분의 공정성 논의에서는 모델이 차별하지 않고자 하는, 즉 상식 상 혹은 특정 맥락에서 만약 차별이 있다면 한 집단이 다른 집단에 비해 이득을 볼 것으로 생각되는 어떤 변수를 선 지정하게 됩니다. 제가 위에서 언급했던 사건들에서는 인종이나 성별이 해당되겠죠. 문헌에서는 주로 이를 민감한 속성(sensitive attributes) 혹은 보호 속성(protected attributes)라는 이름으로 부르는데요. 우리는 전자를 골라 아래처럼 표기하고, 교육 수준이라는 변수를 선택해보겠습니다.</p>
<ul>
<li>차별하지 않고자 하는 민감한 속성: $X_s \subset X$
<ul>
<li>교육 수준(고등학교 졸업 여부)</li>
</ul>
</li>
</ul>
<p>오늘 함께 사용할 <a href="https://github.com/Trusted-AI/AIF360">AI Fiarness 360</a> (AIF 360)은  <strong>머신러닝 모델의 편향을 테스트하고 완화하는 다양한 테크닉들을 포함한 오픈소스 툴킷으로, 파이썬과 R을 둘 다 지원</strong>합니다.</p>
<p>저는 파이썬을 사용하도록 하겠습니다. 우선 보통 많이 사용하는 Pandas 데이터프레임 형태에서 다음과 같이 AIF 360이 잘 받아먹을 수 있는 <code>StandardDataset</code>으로 변경할 것인데, 거의 유사하지만 공정성 판단에 필요한 정보(민감한 속성과 이득을 보는 집단, 그리고 예측 라벨 중에 무엇이 이득인지)을 지정해준 버전의 데이터프레임이라고 생각하면 됩니다. 이 데이터셋을 가지고 모델 학습도 하고(Scikit-learn과 호환성이 꽤 괜찮습니다) AIF360 이 제공하는 각종 테스트와 완화 기법을 적용할 겁니다.</p>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>data <span style="color:#81a1c1">=</span> StandardDataset<span style="color:#eceff4">(</span>df<span style="color:#eceff4">,</span> label_name<span style="color:#81a1c1">=</span><span style="color:#a3be8c">&#39;Loan_Status&#39;</span><span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>                       favorable_classes<span style="color:#81a1c1">=</span><span style="color:#eceff4">[</span><span style="color:#b48ead">1</span><span style="color:#eceff4">],</span> 
</span></span><span style="display:flex;"><span>                       protected_attribute_names <span style="color:#81a1c1">=</span> <span style="color:#eceff4">[</span><span style="color:#a3be8c">&#39;Education&#39;</span><span style="color:#eceff4">],</span> 
</span></span><span style="display:flex;"><span>                       privileged_classes<span style="color:#81a1c1">=</span><span style="color:#eceff4">[</span><span style="color:#b48ead">0</span><span style="color:#eceff4">])</span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">#df는 아래 모델학습 단계 중 최소한의 전처리를 마친 Pandas dataframe</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>favorable_classes</code> : 예측 라벨인 <code>Loan_Status</code> 중 무엇이 이득인지 (여기서는 1=대출 승인)</li>
<li><code>protected_attribute_names</code> : 미리 정한 민감한 속성 (여기서는 교육수준)</li>
<li><code>privileged_classes</code> : 민감한 속성 변수의 라벨 중 중 차별이 있다면 이득을 볼 것으로 생각되는 집단 (여기서는 0=고등학교 졸업자)</li>
</ul>
<p>우선 아무것도 하지 않고 모델 학습을 진행해 보겠습니다.</p>
<ul>
<li>최소한의 전처리
<ul>
<li>결측치 최빈값 또는 평균으로 imputation</li>
<li>카테고리컬 변수(성별, 결혼여부, 교육, 자영업 여부, 신용점수의 과락 통과 여부, 지역)의 인코딩</li>
<li>수치형 변수(본인 수입, 공동 신청자의 수입, 신청 금액, 부양가족 수)의 스케일링</li>
</ul>
</li>
<li>학습, 테스트 셋 7:3으로 분리</li>
</ul>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">#StandardDataset은 바로 split 메서드를 지원, sklearn과 달리 트레이닝 셋의 비율을 입력한다. </span>
</span></span><span style="display:flex;"><span>train<span style="color:#eceff4">,</span> test <span style="color:#81a1c1">=</span> data<span style="color:#81a1c1">.</span>split<span style="color:#eceff4">([</span><span style="color:#b48ead">0.7</span><span style="color:#eceff4">],</span> shuffle<span style="color:#81a1c1">=</span><span style="color:#81a1c1;font-weight:bold">True</span><span style="color:#eceff4">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>모델 학습
<ul>
<li>RandomForestClassifier 사용</li>
</ul>
</li>
</ul>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">from</span> <span style="color:#8fbcbb">sklearn.ensemble</span> <span style="color:#81a1c1;font-weight:bold">import</span> RandomForestClassifier
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">from</span> <span style="color:#8fbcbb">sklearn.metrics</span> <span style="color:#81a1c1;font-weight:bold">import</span> accuracy_score<span style="color:#eceff4">,</span> f1_score
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>base_rf <span style="color:#81a1c1">=</span> RandomForestClassifier<span style="color:#eceff4">()</span><span style="color:#81a1c1">.</span>fit<span style="color:#eceff4">(</span>train<span style="color:#81a1c1">.</span>features<span style="color:#eceff4">,</span> train<span style="color:#81a1c1">.</span>labels<span style="color:#81a1c1">.</span>ravel<span style="color:#eceff4">(),</span>
</span></span><span style="display:flex;"><span>									   sample_weight<span style="color:#81a1c1">=</span>train<span style="color:#81a1c1">.</span>instance_weights<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>base_rf_pred <span style="color:#81a1c1">=</span> base_rf<span style="color:#81a1c1">.</span>predict<span style="color:#eceff4">(</span>test<span style="color:#81a1c1">.</span>features<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">print</span><span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Accuracy Score: &#39;</span><span style="color:#eceff4">,</span> accuracy_score<span style="color:#eceff4">(</span>base_rf_pred<span style="color:#eceff4">,</span> test<span style="color:#81a1c1">.</span>labels<span style="color:#81a1c1">.</span>ravel<span style="color:#eceff4">()))</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">print</span><span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;F1 Score: &#39;</span><span style="color:#eceff4">,</span> f1_score<span style="color:#eceff4">(</span>base_rf_pred<span style="color:#eceff4">,</span> test<span style="color:#81a1c1">.</span>labels<span style="color:#81a1c1">.</span>ravel<span style="color:#eceff4">()))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/accuracy-f1.png#center" width="350"/> 
</figure>

<p>데이터 크기가 600개 남짓인 데다 아무것도 안 한 것 치고는 뭐 그럭저럭인 것 같습니다. 성능을 높이는 건 이 글의 주안점이 아니니 넘어갑시다.</p>
<p>그 다음에 가장 먼저 해야 할 일은 과연 우리의 분류기가 공정한지 테스트부터 해보는 것입니다. 문제가 없는데 해결할 수는 없는 법, 의외로 문제가 없을 수도 있지 않을까요?</p>
<br>
<h2 id="공정한-게-뭔데">‘공정한’ 게 뭔데?<a hidden class="anchor" aria-hidden="true" href="#공정한-게-뭔데">#</a></h2>
<p>테스트를 해보자니 당연히 <strong>공정함이 대체 뭔데?</strong> 라는 의문이 먼저 들 것입니다. 단순히 백인을 10명 가석방시키는 동안 소수인종을 10명 가석방시키면 공정할까요? 입사 점수가 동일하면서 불합격한 인원의 비율이 남녀 간 차이가 없으면 공정할까요? 이런 질문에 일반적인 답을 하려면 왠지 엄청난 철학 공부가 필요할 것 같은 기분이 드는데요, 제가 그쪽의 능력은 전혀 없고요. 아마 머신러닝 모델도 아직 그럴 능력은 없을 겁니다. 모델이 이해하려면 수식으로 쓰인 정의가 필요하죠. 다만 정의가 수식이라는 것보다 더 중요한 사실은, 정의가 여러 가지라는 것입니다.</p>
<p>의외의 사실은 아니겠지만 무엇이 공정한 모델이냐는 질문에는 <strong>여러 가지의 답이 있고 그에 따른 여러 가지의 정의와 여러 가지의 수식</strong>이 있습니다. 이 분야가 처음 주목받기 시작한 이래로 여러 학자들이 너도나도 각자 자신이 생각하는 공정함의 정의를 들고 왔고, 심지어 어떤 논문은 남이 들고 온 정의들의 양립 불가능성(<em>얘가 주장한 A랑 쟤가 주장한 B랑 동시에 만족하는 건 수학적으로 불가능해!</em>)을 증명하기도 했습니다.</p>
<p>결국 <strong>완벽하게 합의된 정의는 없습니다</strong>. 만약 모델을 만들고 사용하는 누군가가 공정한 모델을 원한다면 그 모델의 사회적 활용의 방향성과 본인의 주관에 따라 적절한 정의를 선택해야 하는 상황이 되겠습니다. 이제 제가 왜 위 소제목에서 ‘공정한’에 따옴표를 쳤는지 알겠죠(공정함은 당신 마음 속에 🌟).</p>
<p>AIF360의 <code>ClassificationMetric</code> 클래스를 이용하면 이진분류 모델을 받아 기본적인 분류모델의 성능 관련된 수치들과 <strong>각종 공정성 관련 평가지표들</strong>을 쉽게 알아볼 수 있습니다. (<a href="https://aif360.readthedocs.io/en/latest/modules/generated/aif360.metrics.ClassificationMetric.html#aif360.metrics.ClassificationMetric">문서</a>)</p>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>pgroup <span style="color:#81a1c1">=</span> <span style="color:#eceff4">[</span> <span style="color:#eceff4">{</span><span style="color:#a3be8c">&#39;Education&#39;</span><span style="color:#eceff4">:</span>data<span style="color:#81a1c1">.</span>privileged_protected_attributes<span style="color:#eceff4">[</span><span style="color:#b48ead">0</span><span style="color:#eceff4">]}</span> <span style="color:#eceff4">]</span>
</span></span><span style="display:flex;"><span>upgroup <span style="color:#81a1c1">=</span> <span style="color:#eceff4">[</span> <span style="color:#eceff4">{</span><span style="color:#a3be8c">&#39;Education&#39;</span><span style="color:#eceff4">:</span>data<span style="color:#81a1c1">.</span>unprivileged_protected_attributes<span style="color:#eceff4">[</span><span style="color:#b48ead">0</span><span style="color:#eceff4">]}</span> <span style="color:#eceff4">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>test_pred <span style="color:#81a1c1">=</span> test<span style="color:#81a1c1">.</span>copy<span style="color:#eceff4">()</span>
</span></span><span style="display:flex;"><span>test_pred<span style="color:#81a1c1">.</span>labels <span style="color:#81a1c1">=</span> base_rf_pred
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>metrics <span style="color:#81a1c1">=</span> ClassificationMetric<span style="color:#eceff4">(</span>dataset <span style="color:#81a1c1">=</span> test<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>                               classified_dataset <span style="color:#81a1c1">=</span> test_pred<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>                               privileged_groups <span style="color:#81a1c1">=</span> pgroup<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>                               unprivileged_groups <span style="color:#81a1c1">=</span> upgroup
</span></span><span style="display:flex;"><span>                               <span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">#(un)previleged_groups에는 각 민감한 속성:이익/불이익 집단을 딕셔너리화하여 리스트로 합쳐서 넣어주면 된다</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>그 중에서 우리는 다음 4가지의 지표를 살펴보겠습니다. 이때 앞서 언급한 $X$, $Y$, $d(X)=\hat Y,$  $X_S \subset X$ 의 노테이션은 그대로 사용합니다. $X_S=0$ 이 고등학교 졸업자, $Y=1$이 대출 승인입니다.</p>
<ol>
<li>
<p><strong>Statistical Parity Difference</strong></p>
<ul>
<li>
<p>양성 예측 비율(Positive rate)이 집단 간 동일하면 공정한 모델이라고 본다. 즉, 고등학교 졸업자 중 갚을 것이라고 예측한 사람의 비율과 비졸업자 중 갚을 것이라고 예측한 사람의 비율이 같으면 된다.</p>
</li>
<li>
<p>불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 작은 (음수) 값이며, 0이 이상적</p>
<p>$$
P_{X_S=0}[d(X)=1] - P_{X_S=1}[d(X)=1]
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>Error Rate Difference</strong></p>
<ul>
<li>
<p>정확도(Accuracy)이 집단 간 동일하면 공정한 모델이라고 본다. 고등학교 졸업자에 대한 예측 정확도와 비졸업자에 대한 예측 정확도가 동일하면 된다.</p>
</li>
<li>
<p>불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 큰 값이며, 0이 이상적</p>
<p>$$
P_{X_S=1}[d(X) \neq Y] - P_{X_S=1}[d(X) \neq Y], Y \in {0,1}
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>False Positive Rate Difference</strong></p>
<ul>
<li>
<p>거짓 양성 비율(False Positive Rate)이  집단 간 동일하면, 즉 예측과 민감한 속성이 라벨에 대해 조건부 독립이면 공정한 모델이라고 본다.</p>
</li>
<li>
<p>불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 큰 값이며, 0이 이상적</p>
<p>$$
P_{X_S=1}[d(X) =1 \vert Y=0] - P_{X_S=0}[d(X)=1 \vert Y=0]
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>False Discovery Rate Difference</strong></p>
<ul>
<li>거짓 발견 비율(False Discovery Rate)이 집단 간 동일하면, 즉 모델의 라벨과 민감한 속성이 예측이 주어졌을 때 조건부 독립이면 공정한 모델이라고 본다.</li>
<li>불공정의 정도는 아래와 같이 차이를 구해서 사용 → 불공정할수록 더 큰 값이며, 0이 이상적</li>
</ul>
<p>$$
P_{X_S = 0} [Y=0 \vert d(X) = 1] - P_{X_S =1} [Y=0 \vert d(X)=1 ]
$$</p>
</li>
</ol>
<p>이 외에도 많은 정의들이 있지만, 정답은 뭐다? 각자의 마음속에 있다&hellip; 다만 어떤 정의들의 한계는 명확히 보입니다. 예를 들어 양성 비율만 보는 경우,  $Y$와 $X_S$의 상관을 완전히 무시하게 되죠. 또 만약 어떤 집단에서는 진짜 능력 있는 사람만 1로 예측하고 다른 집단에서는 랜덤하게 아무나 1로 예측한다면 이는 상식적으로 불공정하지만 비율만 같으면 이 기준에서는 공정하게 보일 것입니다. 반면 정확도만 본다면, 한 집단의 FPR과 다른 집단의 FNR 간의 trade가 발생할 수 있습니다. 어떤 경우 한 집단의 능력 있는 사람을 거절하는 비율을 높이고, 다른 집단의 능력 없는 사람에게 대출을 해주는 방식으로 정확도가 동일하게 유지될 수 있는 위험이 있죠.</p>
<p>어쨌든 우리의 막 만든 모델에 대해 4가지 값을 확인해 보면 이렇습니다.</p>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">print</span><span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Statistical Parity Difference: &#39;</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1">-</span>metrics<span style="color:#81a1c1">.</span>statistical_parity_difference<span style="color:#eceff4">())</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">print</span><span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Error Rate Difference: &#39;</span><span style="color:#eceff4">,</span> metrics<span style="color:#81a1c1">.</span>error_rate_difference<span style="color:#eceff4">())</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">print</span><span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;False Positive Rate Difference: &#39;</span><span style="color:#eceff4">,</span> metrics<span style="color:#81a1c1">.</span>false_positive_rate_difference<span style="color:#eceff4">())</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1">print</span><span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;False Discovery Rate Difference: &#39;</span><span style="color:#eceff4">,</span> metrics<span style="color:#81a1c1">.</span>false_discovery_rate_difference<span style="color:#eceff4">())</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/metric-differences.png#center" width="480"/> 
</figure>

<blockquote>
<p>metrics의 모든 수치는 일정하게 (비졸업자 수치 - 졸업자 수치)라 다른 건(Error, FPR, FDR) 다 높을수록 불공정한 거지만 statistical parity만 반대라서 헷갈리지 않도록 부호를 바꿔, 다른 메트릭과 동일하게 클수록 불공정하도록 했습니다.</p></blockquote>
<p>단순 양성 비율만 보는 지표를 제외한 나머지 지표들에서는 <strong>우리의 베이스라인 모델이 고등학교를 나온 사람에게 유리한 결정을</strong> 내리고 있다는 사실을 알 수 있습니다. 특히 COMPAS 케이스처럼 FPR의 차이가 38%대로 눈에 띕니다.</p>
<p>신기한 점은 양성 비율만 봤을 때는 고등학교를 졸업하지 않은 사람의 양성 비율이 8% 정도 더 높다는 것입니다. 즉 <strong>같은 모델인데도 어떤 지표를 보면 불공정하고 다른 지표를 보면 별 문제 없어 보인다</strong>는 것, 그래서 모델을 만들고 데이터를 사용하는 사람의 주관적 결정이 중요하다는 것이 결론이 되기도 하겠습니다.</p>
<br>
<h2 id="어떻게-해결하지">어떻게 해결하지?<a hidden class="anchor" aria-hidden="true" href="#어떻게-해결하지">#</a></h2>
<p>위의 등장한 정의들은 일종의 메트릭입니다. 그리고 방금 제 모델이 그랬듯 아무런 조치 없이 모델을 훈련시킨다면 아마 공정의 정의를 무엇으로 선택하든 만족하지 못할 확률이 높을 겁니다. 그러면 이제, 이 불공정한 모델을 어떻게 고쳐볼까의 질문으로 넘어가 봅시다.</p>
<p>공정함의 조건을 만족하지 못하는, 즉 편향이 있는 모델에 대해 편향을 완화(mitigation)시키는 테크닉들은 크게 어떤 단계에서 행하느냐에 따라 전처리, 학습, 사후 처리 이렇게 3가지로 나뉩니다. 요약해 보면 다음과 같습니다.</p>
<ol>
<li>전처리를 통한 편향 완화 (Pre-Processing)
<ul>
<li>모델의 인풋 데이터를 잘 고쳐보자!
<ul>
<li>데이터를 리샘플링하거나 가중치를 잘 분배해보기</li>
<li>집단 간 클래스 라벨을 뒤집어보기</li>
<li>민감한 특성을 아예 생략해보기</li>
<li>특정 공정함 조건을 만족시키도록 인풋 데이터를 변형시키는 모델 또는 함수를 학습시키기</li>
</ul>
</li>
</ul>
</li>
<li>학습 시 편향 완화 (In-Processing)
<ul>
<li>모델 학습 방식을 바꿔서 정확도와 공정함을 모두 목표로 하도록 모델을 훈련시켜보자!
<ul>
<li>적대적 학습을 이용(타겟 데이터를 예측하는 모델 ↔ 그 모델로 민감한 특성을 예측하는 모델, 후자가 민감한 특성을 예측할 수 없도록)</li>
<li>Loss function에 공정함 관련 제약 값(constraint) 을 추가하기</li>
</ul>
</li>
</ul>
</li>
<li>사후 처리를 통한 편향 완화 (Post-Processing)
<ul>
<li>데이터와 모델은 그대로 유지하고, 최종 아웃풋만 잘 조정해보자!
<ul>
<li>특정 공정함 조건을 만족시키도록 그룹 별로 최종 분류 threshold를 최적화하기</li>
<li>특정 공정함 조건을 만족시키도록 아웃풋 데이터를 변형시키는 모델 또는 함수를 학습시키기</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>AIF 360은 각 단계별로 여러 가지의 편향 완화 알고리즘을 제공해주고 있습니다. <a href="https://aif360.readthedocs.io/en/latest/modules/algorithms.html">문서</a>에서 세어봤는데요, 전처리에서 4개, 학습 시 7개, 사후처리 3개가 있네요.</p>
<p>이 글에서는 각 단계별로 1개씩만 사용해보고 베이스 모델과 성능 및 공정성 지표를 비교해볼 것입니다. 우선 각 기법의 접근방식을 요약하고 코드 및 논문을 함께 달아두겠습니다.  각 방법이 더 궁금하다면 링크된 논문을, 그 외의 다른 기법들이 궁금하다면 AIF 360 문서에서 확인할 수 있습니다.</p>
<br>
<h3 id="전처리-reweighing">[전처리] Reweighing<a hidden class="anchor" aria-hidden="true" href="#전처리-reweighing">#</a></h3>
<ul>
<li><a href="https://link.springer.com/article/10.1007/s10115-011-0463-8">Data preprocessing techniques for classification without discrimination</a>
<ul>
<li>민감한 속성과 라벨 조합 별로 다르게 가중치를 두어 학습하는데, 차별이 존재하는 방향과 일치하는(일반적인 편견에 부합하는) 데이터는 가중치를 낮게 주고 반대는 높게 준다.</li>
<li>즉 대출을 승인받은 고등학교 비졸업자는 대출을 승인받지 못한 고등학교 비졸업자보다 높은 가중치를 부여하고, 반대로 대출을 승인받지 못한 고등학교 졸업자 데이터에 대출을 승인받은 고등학교 졸업자보다 높은 가중치를 부여한다.</li>
</ul>
</li>
</ul>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>RW <span style="color:#81a1c1">=</span> Reweighing<span style="color:#eceff4">(</span>unprivileged_groups<span style="color:#81a1c1">=</span>upgroup<span style="color:#eceff4">,</span> privileged_groups<span style="color:#81a1c1">=</span>pgroup<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>rw_train <span style="color:#81a1c1">=</span> RW<span style="color:#81a1c1">.</span>fit_transform<span style="color:#eceff4">(</span>train<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>rw_rf <span style="color:#81a1c1">=</span> RandomForestClassifier<span style="color:#eceff4">()</span><span style="color:#81a1c1">.</span>fit<span style="color:#eceff4">(</span>rw_train<span style="color:#81a1c1">.</span>features<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>									 rw_train<span style="color:#81a1c1">.</span>labels<span style="color:#81a1c1">.</span>ravel<span style="color:#eceff4">(),</span>
</span></span><span style="display:flex;"><span>									 sample_weight <span style="color:#81a1c1">=</span> rw_train<span style="color:#81a1c1">.</span>instance_weights<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>rw_test <span style="color:#81a1c1">=</span> RW<span style="color:#81a1c1">.</span>transform<span style="color:#eceff4">(</span>test<span style="color:#eceff4">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="학습-adversarial-debiasing">[학습] Adversarial Debiasing<a hidden class="anchor" aria-hidden="true" href="#학습-adversarial-debiasing">#</a></h3>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3278721.3278779">Mitigating Unwanted Biases with Adversarial Learning</a>
<ul>
<li>예측변수(대출 승인 여부)를 예측하는 모델과 민감한 속성(교육 수준)을 예측하는 적대적 모델을 만들어 전자의 성능을 최대화, 후자의 성능을 최소화하도록 학습한다.</li>
<li>즉 이 방식의 목표는 그 예측 결과만 보고 민감한 속성 여부를 예측하기 어려운 모델을 만드는 것.</li>
</ul>
</li>
</ul>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sess <span style="color:#81a1c1">=</span> tf<span style="color:#81a1c1">.</span>Session<span style="color:#eceff4">()</span>
</span></span><span style="display:flex;"><span>tf<span style="color:#81a1c1">.</span>disable_eager_execution<span style="color:#eceff4">()</span>
</span></span><span style="display:flex;"><span>ad <span style="color:#81a1c1">=</span> AdversarialDebiasing<span style="color:#eceff4">(</span>privileged_groups <span style="color:#81a1c1">=</span> pgroup<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>						  unprivileged_groups <span style="color:#81a1c1">=</span> upgroup<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>						  scope_name<span style="color:#81a1c1">=</span><span style="color:#a3be8c">&#39;debiased_classifier&#39;</span><span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>						  num_epochs<span style="color:#81a1c1">=</span><span style="color:#b48ead">10</span><span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>						  debias<span style="color:#81a1c1">=</span><span style="color:#81a1c1;font-weight:bold">True</span><span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>						  sess<span style="color:#81a1c1">=</span>sess<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>ad<span style="color:#81a1c1">.</span>fit<span style="color:#eceff4">(</span>train<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>ad_pred <span style="color:#81a1c1">=</span> ad<span style="color:#81a1c1">.</span>predict<span style="color:#eceff4">(</span>test<span style="color:#eceff4">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="사후처리-reject-option-classification">[사후처리] Reject Option Classification<a hidden class="anchor" aria-hidden="true" href="#사후처리-reject-option-classification">#</a></h3>
<ul>
<li><a href="https://ieeexplore.ieee.org/document/6413831/">Decision Theory for Discrimination-Aware Classification</a>
<ul>
<li>모델은 예측 결과에 대해 확신이 있을 때가 아니라 헷갈릴 때 차별을 하게 된다고 본다. 예를 들면 결정 경계(decision boundary)가 0.5일 때, 어떤 데이터가 0.1이나 0.9이면 문제 없이 예측하지만 0.49나 0.51이라면 예측 불확실성이 높아지는데, 그래도 최대한 예측을 잘 하기 위해 일반적으로 이득을 보는 집단에게 더 좋은 결과(ex. 대출 승인)을 주게 된다는 것이다. 사람도 정확한 정보만으로 판단하기 애매한 케이스가 주어지면 편견에 따라 행동할 수 있다는 점을 생각하면 오..그러네..🤔? 하게 되는 아이디어.</li>
<li>따라서 이 방법은 학습이 완료된 모델의 예측 데이터를 가지고 결정 경계 근처의, 불확실성이 가장 높은 데이터만 고등학교 졸업자는 거절, 비졸업자는 승인으로 바꿔준다.</li>
</ul>
</li>
</ul>
<div class="highlight"><div style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6c6f74">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>ROC <span style="color:#81a1c1">=</span> RejectOptionClassification<span style="color:#eceff4">(</span>privileged_groups <span style="color:#81a1c1">=</span> pgroup<span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>							 unprivileged_groups <span style="color:#81a1c1">=</span> upgroup<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ROC <span style="color:#81a1c1">=</span> ROC<span style="color:#81a1c1">.</span>fit<span style="color:#eceff4">(</span>test<span style="color:#eceff4">,</span> base_test_pred<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>roc_test_pred <span style="color:#81a1c1">=</span> ROC<span style="color:#81a1c1">.</span>predict<span style="color:#eceff4">(</span>base_test_pred<span style="color:#eceff4">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><br>
<h3 id="완화-처리의-효과는">완화 처리의 효과는?<a hidden class="anchor" aria-hidden="true" href="#완화-처리의-효과는">#</a></h3>
<p>이제 제일 처음 학습시켰던 베이스 모델과 저 3가지 테크닉을 각자 적용한 추가 3개의 모델을 비교해볼 것입니다.</p>
<p>이전에 확인했던 4개의 공정성 지표가 얼마나 달라졌는지도 궁금하지만, 일반적으로 편향을 제거하기 위한 조치를 취하면 모델 성능은 떨어질 것 같은데 과연 그럴지도 궁금합니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/models-result.png#center" width="480"/> 
</figure>

<p>우선 성능부터 보면, Reweighing 외 다른 2개의 기법은 기존 모델에 비해 성능이 감소했음을 알 수 있습니다. 사실 공정성을 위해 보정하다 보면 성능이 떨어진다는 것은 이 공정성 논의에서 항상 당연한 것처럼 언급이 되었던 사실입니다. 다만 최근에는 <a href="https://proceedings.mlr.press/v119/dutta20a.html">trade-off 가 무조건 발생하는 것이 아니며, 항상 정확도와 공정성 간의 이상적인 최적 지점을 찾을 수 있다는 것을 이론적으로 증명하는 논문</a>도 나오고 했더라고요.</p>
<p>이제 각 공정성 지표의 모델별 차이를 보겠습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/fpr.png#center" width="480"/> 
</figure>

<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/sp.png#center" width="480"/> 
</figure>

<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/er.png#center" width="480"/> 
</figure>

<figure class="align-center ">
    <img loading="lazy" src="/posts/ai-fairness-tutorial/fdr.png#center" width="480"/> 
</figure>

<ul>
<li>가장 차이가 심각했던 FPR 지표의 경우 3개의 완화 기법 모두 어느 정도 성공적으로 낮추었고, Adversarial Learning이 가장 효과가 좋다.</li>
<li>Statistical Parity의 경우는 각 모델 별로 불공정의 방향성이 다른데, 모두 5% 미만대로 큰 수치는 아니라 의미가 없어 보인다.</li>
<li>Error Rate이나 FDR의 경우, 일부 모델은 오히려 불공정 정도가 베이스 모델에 비해 심화되었다.</li>
<li>모델 기준으로 종합해보면 Adversarial Learning이 모든 지표를 상당 수준 이하 감소시켰으나 성능 또한 가장 큰 폭으로 감소한 기법이었다. Reweighing의 경우 성능은 유지되었으나 FPR 외의 다른 지표에서 편향을 완화하지 못했고 오히려 더 증폭하는 영향이 있었다.</li>
</ul>
<p>여기까지 보았을 때 결론은 <strong>어떤 지표를 공정성의 정의로 사용하느냐에 따라 선택할 수 있는 완화 기법도 크게 달라질 수 있다는 것, 그리고 어떤 정의와 모델을 택하든 (최적 포인트를 찾지 못하면) 공정성과 성능 간 trade-off가 존재할 가능성이 있다</strong>는 것이 되겠습니다.</p>
<br>
<h2 id="참고한-글들">참고한 글들<a hidden class="anchor" aria-hidden="true" href="#참고한-글들">#</a></h2>
<ul>
<li><a href="https://fairware.cs.umass.edu/papers/Verma.pdf">Fairness Definitions Explained</a></li>
<li><a href="https://towardsdatascience.com/algorithms-for-fair-machine-learning-an-introduction-2e428b7791f3">Algorithms for Fair Machine Learning: An Introduction</a></li>
<li><a href="https://www.kaggle.com/nathanlauga/ethics-and-ai-how-to-prevent-bias-on-ml">Ethics and AI : how to prevent bias on ML?</a></li>
</ul>
<br>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sliceofdata.app/tags/fairness/">Fairness</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 차별하지 않는 분류 모델 만들기 on x"
            href="https://x.com/intent/tweet/?text=%ec%b0%a8%eb%b3%84%ed%95%98%ec%a7%80%20%ec%95%8a%eb%8a%94%20%eb%b6%84%eb%a5%98%20%eb%aa%a8%eb%8d%b8%20%eb%a7%8c%eb%93%a4%ea%b8%b0&amp;url=https%3a%2f%2fsliceofdata.app%2fposts%2fai-fairness-tutorial%2f&amp;hashtags=fairness">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 차별하지 않는 분류 모델 만들기 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsliceofdata.app%2fposts%2fai-fairness-tutorial%2f&amp;title=%ec%b0%a8%eb%b3%84%ed%95%98%ec%a7%80%20%ec%95%8a%eb%8a%94%20%eb%b6%84%eb%a5%98%20%eb%aa%a8%eb%8d%b8%20%eb%a7%8c%eb%93%a4%ea%b8%b0&amp;summary=%ec%b0%a8%eb%b3%84%ed%95%98%ec%a7%80%20%ec%95%8a%eb%8a%94%20%eb%b6%84%eb%a5%98%20%eb%aa%a8%eb%8d%b8%20%eb%a7%8c%eb%93%a4%ea%b8%b0&amp;source=https%3a%2f%2fsliceofdata.app%2fposts%2fai-fairness-tutorial%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
<div class="container_disqus">
    <script src="https://giscus.app/client.js"
        data-repo="pizzathiefz/sliceofdata"
        data-repo-id="R_kgDOPsr6oQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOPsr6oc4CvOfW"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme=""
        data-lang="en"
        crossorigin="anonymous"
        async>
    </script>
</div>
<script>
    
    function getCurrentTheme() {
        
        let storedTheme = localStorage.getItem('pref-theme');
        if (storedTheme) {
            return storedTheme;
        }
        
        
        if (document.body.classList.contains('dark')) {
            return 'dark';
        }
        
        
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        
        return 'light';
    }
    
    
    function setGiscusTheme() {
        let currentTheme = getCurrentTheme();
        let giscusTheme = currentTheme === 'dark' ? 'noborder_dark' : 'noborder_light';
        
        
        let giscusScript = document.querySelector("div.container_disqus > script");
        if (giscusScript) {
            giscusScript.setAttribute('data-theme', giscusTheme);
        }
        
        return giscusTheme;
    }
    
    
    setGiscusTheme();
    
    
    document.addEventListener('DOMContentLoaded', function() {
        let themeToggle = document.querySelector('#theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                setTimeout(() => {
                    let newTheme = getCurrentTheme();
                    let newGiscusTheme = newTheme === 'dark' ? 'noborder_dark' : 'noborder_light';
                    
                    let giscusFrame = document.querySelector('iframe.giscus-frame');
                    if (giscusFrame) {
                        giscusFrame.contentWindow.postMessage({
                            giscus: {
                                setConfig: {
                                    theme: newGiscusTheme
                                }
                            }
                        }, 'https://giscus.app');
                    }
                }, 100);
            });
        }
    });
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://sliceofdata.app/">sliceofdata</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
