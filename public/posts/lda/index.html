<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>잠재 디리클레 할당 (LDA) 뜯어보기 | sliceofdata</title>
<meta name="keywords" content="lda, latent dirichlet allocation, 토픽 모델링, topic modeling">
<meta name="description" content="Latent는 뭐고 Dirichlet는 뭐고 Allocation은 뭔데">
<meta name="author" content="pizzathief">
<link rel="canonical" href="https://sliceofdata.app/posts/lda/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.27cad2a1c5348b9448235a32de472a54bfb4b517f58e15427dc5a1a01bf486da.css" integrity="sha256-J8rSocU0i5RII1oy3kcqVL&#43;0tRf1jhVCfcWhoBv0hto=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sliceofdata.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sliceofdata.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sliceofdata.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sliceofdata.app/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://sliceofdata.app/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="https://sliceofdata.app/posts/lda/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {
  delimiters: [
    {left: '$$', right: '$$', display: true},
    {left: '$', right: '$', display: false},
    {left: '\\(', right: '\\)', display: false},
    {left: '\\[', right: '\\]', display: true}
  ],
  throwOnError: false
});"></script>
<meta property="og:url" content="https://sliceofdata.app/posts/lda/">
  <meta property="og:site_name" content="sliceofdata">
  <meta property="og:title" content="잠재 디리클레 할당 (LDA) 뜯어보기">
  <meta property="og:description" content="Latent는 뭐고 Dirichlet는 뭐고 Allocation은 뭔데">
  <meta property="og:locale" content="ko-KR">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-10-02T17:03:51+09:00">
    <meta property="article:modified_time" content="2022-10-02T17:03:51+09:00">
    <meta property="article:tag" content="Nlp">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="잠재 디리클레 할당 (LDA) 뜯어보기">
<meta name="twitter:description" content="Latent는 뭐고 Dirichlet는 뭐고 Allocation은 뭔데">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sliceofdata.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "잠재 디리클레 할당 (LDA) 뜯어보기",
      "item": "https://sliceofdata.app/posts/lda/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "잠재 디리클레 할당 (LDA) 뜯어보기",
  "name": "잠재 디리클레 할당 (LDA) 뜯어보기",
  "description": "Latent는 뭐고 Dirichlet는 뭐고 Allocation은 뭔데",
  "keywords": [
    "lda", "latent dirichlet allocation", "토픽 모델링", "topic modeling"
  ],
  "articleBody": "오늘은 잘 알려진 토픽 모델링 기법인 LDA에 대해서 알아보겠습니다. LDA는 Latent Dirichlet Allocation, 즉 잠재 디리클레 할당이라는 이름이며, 보다시피 이 이름은 3개의 단어로 이루어져 있습니다. 이 세 단어를 하나씩 뜯어보면 LDA를 이해할 수 있습니다.\n잠재 잠재란 드러나지 않는다는 뜻입니다. LDA는 우리가 보고 있는 데이터인 문서가 숨겨져서 드러나지 않는 어떤 과정의 결과물이라고 가정합니다.\n예를 들어,\n널 초코칩으로 스프링클로 입맛 버리게 만들고 싶어, 숨기고 있지만 널 더 보고 싶어\n누군가가 이런 문서를 썼다고 합시다. (출처)\n이 문서가 만들어진 잠재적인(눈에 보이지 않는) 과정은 뭘까? 라는 질문에서 출발합시다. 이 말을 조금 더 쉽게 바꾸면, 이 문서를 쓴 사람은 어떤 과정을 거쳐서 이런 단어들을 골라서 쓰게 되었을까요?\n이 사람은 처음에 2가지 주제에 대해서 쓰고 싶었을 것이다. 1번 주제: 쿠키 🍪 2번 주제: 상대방에 대한 관심(Attention) 비중은 한 반반 정도? 50%는 쿠키에 대해, 50%는 관심에 대해. 일단 하나의 주제를 정하면, 그 주제에 따라서 쓰기 쉬운 단어가 정해진다. 초코칩은 쿠키라는 주제에서 나오기 쉬운 말이다. 보고싶어는 관심이라는 주제에서 나오기 쉬운 말이다. 다른 주제를 골랐더라면 단어가 달라졌을 것이다. 만약에 피자를 골랐다면, 널 페퍼로니로 치즈로 입맛 버리게 만들고 싶어 라고 썼겠지! 쿠키를 골랐을 때 초코가 나올 확률 \u003e 피자를 골랐을 때 초코가 나올 확률 피자를 골랐을 때 페퍼로니가 나올 확률 \u003e 쿠키를 골랐을 때 페퍼로니가 나올 확률 결국 문서를 작성한다는 것은, 이런 식으로 이루어질 것이다. 문서 내에서 어떤 확률에 따라 주제를 고른다. 쿠키:50%, 관심: 50%, 피자 0% 주제는 각각 어떤 확률에 따라서 단어를 고른다. 쿠키라는 주제에 대해 각 단어가 등장할 확률은 초코칩: 40%, 충치: 10%, 페퍼로니 0% …. 2개의 과정을 거쳐 만들어진 단어의 집합이 하나의 문서가 된다. 문제는 이 모든 과정이 잠재적이라는 것입니다.\n이렇게 ‘문서를 쓰게 된 과정’을 상상해봤지만, 사실 우리는 이 과정의 세부 디테일을 모릅니다. 쿠키 50%, 관심 50% 이런 정보는 문서 어디에도 써있지 않으며 우리가 알 수 있는 건 그 과정의 결과물인 단어들 뿐입니다. 즉 지금 우리가 해야 하는 것은 단어들을 보고, 미지의 확률값들을 추론하는 것입니다. (숨기고 있지만 널 더 보고 싶어!)\n그래서 우리에게 필요한 것은 기본적으로 베이지안 추론입니다. 베이지안 추론은 간단하게,\n궁금한 사건에 대해 잘 모르지만 일단 특정 확률에 따라 발생한다고 믿어본다.(사전 확률 분포) 사건을 관측해서 추가적인 정보를 얻는다. 얻은 정보에 더 들어맞도록 내 가정을 수정한다. (사후 확률 분포) 밑에서 더 자세히 살펴보겠지만 LDA가 바로 이런 방식으로 동작합니다. 여기서 관심 있는 사건이 문서이고, LDA는 주어진 문서가 가장 나올 법한 확률 분포를 찾아가는 과정이죠.\n왠지 이 문서는 피자에 대한 것일 것 같아. → 앗 피자 관련된 말이 하나도 안 나왔어. → 피자에 대한 문서는 아닐 수도 있겠군. 이렇게 보면 나름 자연스러운 추론 과정이죠? 문제는 대충 ‘~에 대한 것일 것 같아’가 아니라 숫자로 된 파라미터를 가진 ‘확률 분포’가 필요하다는 것입니다. 그래서 이 때 다음 단어가 등장합니다.\n디리클레 디리클레는 확률 분포의 이름입니다. 결론부터 말하면 디리클레 분포는 다항분포의 사전 켤레 분포이기 때문에 사용됩니다. 뭔 소리인지 모르겠으므로 풀어서 설명해 보겠습니다.\n일단 다시 우리의 잠재적 가정으로 돌아가서, 주제가 정해졌을 때 단어를 고르는 상황을 상상해 봅시다. 주머니에 수많은 단어카드가 들어 있는데, 각 단어카드가 몇개씩 들어 있는지는 주제별 단어 분포에 따라 다를 것입니다. 주머니에 손을 넣어 아무 카드나 뽑는 걸 반복합니다. 독립적 시행이며, 같은 단어는 여러 번 반복해서 나올 수 있습니다.\n이런 경우, 단어를 뽑은 결과는 다항분포를 따르지 않을까 생각해볼 수 있습니다. 다항분포의 확률질량함수(정해진 확률 파라미터에 따라 주어진 관측 결과가 나올 확률값을 돌려주는 함수라고 생각하면 됩니다)는 이렇게 생겼습니다.\n$$ f(x_1, \\dots, x_k ; n, p_1, \\dots , p_k) = \\frac{n!}{x_1! \\dots x_k!} p_1^{x_1} \\dots p_k^{x_k} $$\n$k$개의 단어가 있고, 각 단어가 나타날 확률이 각각 $p_1$, … $p_k$로 정해져 있을 때 , $n$번을 뽑았을 때 단어가 $x_1$, …, $x_k$개씩 나타날 확률은 위와 같다. ($p$는 확률이므로 $p$를 다 더한 값은 1이며, $x$를 다 더한 것은 $n$일 것.) 쉽게 말하면 다항분포는 주사위 10번 던졌는데 1이 3번, 4가 7번 나올 확률은 어떻게 돼? 라는 질문에 대한 답을 주는 분포다. 이 경우 모든 $p$가 1/6이고, $n$이 10이고, $x$는 (3,0,0,7,0,0)이므로 저 식에 따라서 확률을 계산할 수 있다. 하지만 앞서 언급했듯 우리는 확률값을 전혀 모르기 때문에 사전 확률을 정한 다음 업데이트를 통해 사후 분포를 얻는 전략을 취할 겁니다. 그래서 사전 확률 분포를 뭐로 정할 것이냐의 문제인데요. 사전 확률 분포와 사후 확률 분포가 같은 가족군일 때 이들을 켤레분포라고 하며, 만약에 켤레 사전 분포(conjugate prior)를 사전 분포로 사용할 경우 사후 분포 업데이트에 필요한 계산이 매우 편해지기 때문에 켤레 사전 분포를 사전 분포로 고르게 됩니다.\n❓ (참고) 켤레 사전 분포 만약 단어가 2개밖에 없다면 → 이항분포(Binomial) 이항분포의 켤레 사전 분포는 베타 분포 단어가 여러 개이면 → 다항분포(Multinomial) 다항 분포의 켤레 사전 분포는 디리클레 분포 다항분포의 켤레 사전 분포인 디리클레 분포를 살펴 보기 전에, 왜 따로 사전 분포가 필요한데? 사후 분포랑 뭐가 다른데? 라는 생각을 해보면,\n다항분포는 각 사건의 확률 정보를 파라미터로서 알고 있어야 한다. 즉 각 단어가 나올 확률을 안다고 가정하고, 그 설정 하에서 최종 관측치(문서)의 확률을 알 수 있게 된다. p( 관측치 | 확률 정보) 주사위를 던지는데 각 숫자가 나올 확률은 1/6인데 이런 관측치가 나올 확률은? 디리클레 분포는 이걸 거꾸로 한 것. 우리가 아는 건 최종 관측치(문서)일 뿐이므로, 문서가 주어졌을 때 각 단어의 확률이 어떨지를 나타내주는 함수이다. 관측치가 파라미터다. p( 확률 정보 | 관측치 ) 주사위를 던지는데 이런 관측치가 나왔는데 각 숫자가 나올 확률은? 디리클레 분포의 확률밀도함수는 이렇게 생겼습니다(다항분포와 달리 연속확률분포입니다).\n$$ f(p_1, \\dots, p_k ; \\alpha_1, \\dots, \\alpha_k) = \\frac{1}{ B(\\alpha)} \\prod_{i = 1}^k p_i^{\\alpha_i-1} $$\n$$ B(\\alpha) = \\frac{\\prod_{i=1}^{k} \\gamma (\\alpha_i)}{\\gamma (\\sum^k_{i=1} \\alpha_i)} $$\n우리가 관측하기로 총 $k$개의 단어가 있고, 각각 $\\alpha$ 번씩 등장했을 때, 이 함수는 각 단어가 등장할 확률이 $p$일 확률값을 돌려준다. (역시 모든 $p$의 합은 1) $B(\\alpha)$는 $\\alpha$ 값과 감마함수에 따라 결정되는 정규화 상수다. 이해를 위해 단어가 3개 있다고 가정할 때 $\\alpha$ 값에 따라 확률밀도함수가 어떻게 달라지는지 보겠습니다.\n그림 출처\n위: 3개가 모두 동일한 횟수로 (5번씩) 나왔는데 각 단어가 등장할 확률은 아마 비슷하겠지? 아래: 세번째 단어가 8번 나오는 동안 첫번째, 두번째 단어는 2번, 4번 나왔는데 3번째 단어가 나올 확률이 제일 높겠지? 이제 LDA가 가정하는 잠재적인 과정과 이용하는 확률 분포에 대해 알았습니다. 마지막 단어로 넘어가서, LDA가 실제로 어떻게 주제를 찾는지 알아보겠습니다.\n할당 LDA의 최종 목표는 단어별로 문서별로 주제를 할당하는 것입니다. 어떻게 할까요? 그 과정은 다음과 같이 하나의 도식으로 나타낼 수 있습니다.\n그림 출처\n2개의 분포가 있다. 문서마다 있는 주제 분포 (Document-Topic distribution) $M$개의 문서가 존재 (분포도 $M$개!) $\\theta_m \\sim \\text{Dir}(\\alpha)$ : $\\alpha$ 라는 파라미터를 지닌 디리클레 분포를 사전분포로 쓰겠다는 뜻. $\\theta$는 그 문서에서 주제에 대한 확률값 벡터가 된다. ex) 쿠키:50%, 관심: 50%, 피자 0% 주제마다 있는 단어 분포 (Topic-Word Distribution) $K$개의 주제가 존재 (분포도 $K$개!) $\\varphi_k \\sim \\text{Dir}(\\beta)$ : $\\beta$라는 파라미터를 지닌 디리클레 분포를 사전분포로 쓰겠다는 뜻. $\\varphi$ 는 그 주제에서 단어에 대한 확률값 벡터가 된다. ex) 초코칩: 40%, 충치: 10%, 페퍼로니 0% …. 관측된 단어(Obsered Word)에 주제를 할당(Word-Topic assignment) 해보자. $N$개의 단어가 존재 각 문서에 존재하는 관측된 단어 $w_{m,n}$ 에 대해 주제 $z_{m,n}$을 정해보자. 두가지 분포의 결합으로 단어가 나타난다. 즉 단어의 결정은 문서-주제 분포로 결정된 주제($z$)와 그 주제의 주제-단어 분포를 결정하는 파라미터($\\beta$)의 영향을 받는데, $p(w_n \\mid z_n, \\beta)$ 이 확률이 컸으면 좋겠다 = 이 확률이 커지는 주제를 할당하고 싶다. 이 추론 방식을 풀어 쓰면, 초코칩이라는 단어가 나타난 것은 이 문서가 쿠키라는 주제가 높은 확률로 등장하는 분포이기 때문에, 쿠키라는 주제는 초코칩이 높은 확률로 등장하는 분포이기 때문에… 이 ‘때문에’가 말이 되려면 이 여러 개의 변수 중 우리가 모르는 값들을(사실 $w$ 빼고 다 모름) 관측된 사건의 확률을 크게 해주는 방향으로 설정해주면 된다. 결국 단어에 주제를 할당할 때 목적은, 우리가 가정한 분포와 잠재적 과정이 우리가 실제로 관측한 단어를 최대한 잘 설명할 수 있도록 하는 것. LDA는 이 목적을 달성하기 위해 베이지안 통계에서 자주 등장하는 깁스 샘플링(Gibbs Sampling)이라는 기법을 사용합니다. 단어의 개수가 많아질수록 우리가 추정해야 하는 값들의 차원이 엄청나게 늘어나기 때문에 추론에 필요한 계산을 가능하게 해주는 방법입니다.\n전체 과정을 순서대로 설명하면 다음과 같습니다. 토픽의 개수인 $K$는 미리 지정해 주어야 합니다. 사전분포의 파라미터 값들($\\alpha,$ $\\beta$)도요.\n모든 단어에 아무 주제나 할당한다. 그러면 이 값에 따라 우리의 관심사인 2개의 분포가 결정된다. 아무렇게나 정했기 때문에 당연히 엉망일 것이다. 이제 업데이트를 하자. 1개의 단어를 고르고, 이 1개의 단어를 제외하고 나머지 단어들은 다 정답인 주제로 배정되어 있다고 가정한다. 나머지 단어들만 사용해서 이 문서의 주제 분포와 각 주제의 단어분포를 다시 계산한다. 이 분포를 기반으로 이 1개의 단어에 각 주제가 할당될 확률을 계산한 후 $p(z_i \\mid z_{-i}, w)$ 가장 확률이 높은 주제로 재할당한다. P(주제 $\\mid$ 분포) x P(단어 $\\mid$ 주제) 를 나머지 단어들의 카운트를 통해 계산하면 된다. 지금까지 설명한 단어 선정 방식과 직관적으로 일치하는 내용. 문서 내 모든 단어에 대해 이것을 반복한다. 이것이 1회의 깁스 샘플링이다. 샘플링(재할당)을 반복하다보면 더 이상 변동이 없이 안정적으로 수렴하는 순간이 올 것이다. 거기서 멈춘다. 멈췄을 때 얻은 모든 단어의 주제 분포를 사용해서 단어의 집합인 각 문서에 주제를 할당한다. 참고한 글들 Topic Modeling, LDA 잠재 디리클레 할당 파헤치기 2. 디리클레 분포와 LDA ",
  "wordCount" : "1354",
  "inLanguage": "ko",
  "datePublished": "2022-10-02T17:03:51+09:00",
  "dateModified": "2022-10-02T17:03:51+09:00",
  "author":{
    "@type": "Person",
    "name": "pizzathief"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sliceofdata.app/posts/lda/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "sliceofdata",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sliceofdata.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sliceofdata.app/" accesskey="h" title="slice.of.data (Alt + H)">
                <img src="https://sliceofdata.app/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">slice.of.data</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://sliceofdata.app/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sliceofdata.app/archives/" title="posts">
                    <span>posts</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/about/" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://sliceofdata.app/subscribe" title="subscribe">
                    <span>subscribe</span>
                </a>
            </li>
            <li>
                <a href="https://pizzathief.pages.dev/" title="notes">
                    <span>notes</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      잠재 디리클레 할당 (LDA) 뜯어보기
    </h1>
    <div class="post-meta"><span title='2022-10-02 17:03:51 +0900 KST'>2022-10-02</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;pizzathief&nbsp;|&nbsp;<a href="https://github.com/pizzathiefz/sliceofdata/blob/main/content/posts/lda/index.ko.md" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#잠재">잠재</a></li>
    <li><a href="#디리클레">디리클레</a></li>
    <li><a href="#할당">할당</a></li>
    <li><a href="#참고한-글들">참고한 글들</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>오늘은 잘 알려진 토픽 모델링 기법인 LDA에 대해서 알아보겠습니다. LDA는 Latent Dirichlet Allocation, 즉 잠재 디리클레 할당이라는 이름이며, 보다시피 이 이름은 3개의 단어로 이루어져 있습니다. 이 세 단어를 하나씩 뜯어보면 LDA를 이해할 수 있습니다.</p>
<h2 id="잠재">잠재<a hidden class="anchor" aria-hidden="true" href="#잠재">#</a></h2>
<figure class="align-center ">
    <img loading="lazy" src="/posts/lda/latent.png#center" width="300"/> 
</figure>

<p>잠재란 드러나지 않는다는 뜻입니다. LDA는 우리가 보고 있는 데이터인 <strong>문서</strong>가 숨겨져서 드러나지 않는 어떤 과정의 결과물이라고 가정합니다.</p>
<p>예를 들어,</p>
<blockquote>
<p>널 초코칩으로 스프링클로 입맛 버리게 만들고 싶어, 숨기고 있지만 널 더 보고 싶어</p></blockquote>
<p>누군가가 이런 문서를 썼다고 합시다. (<a href="https://youtu.be/VOmIplFAGeg">출처</a>)</p>
<p>이 문서가 만들어진 잠재적인(눈에 보이지 않는) 과정은 뭘까? 라는 질문에서 출발합시다. 이 말을 조금 더 쉽게 바꾸면, 이 문서를 쓴 사람은 <strong>어떤 과정을 거쳐서 이런 단어들을 골라서 쓰게 되었을까요</strong>?</p>
<ul>
<li>이 사람은 처음에 2가지 주제에 대해서 쓰고 싶었을 것이다.
<ul>
<li>1번 주제: 쿠키 🍪</li>
<li>2번 주제: 상대방에 대한 관심(<a href="https://youtu.be/js1CtxSY38I">Attention</a>)</li>
<li>비중은 한 반반 정도? 50%는 쿠키에 대해, 50%는 관심에 대해.</li>
</ul>
</li>
<li>일단 하나의 주제를 정하면, 그 주제에 따라서 쓰기 쉬운 단어가 정해진다.
<ul>
<li><code>초코칩</code>은 쿠키라는 주제에서 나오기 쉬운 말이다.</li>
<li><code>보고싶어</code>는 관심이라는 주제에서 나오기 쉬운 말이다.</li>
</ul>
</li>
<li>다른 주제를 골랐더라면 단어가 달라졌을 것이다.
<ul>
<li>만약에 피자를 골랐다면, <code>널 페퍼로니로 치즈로 입맛 버리게 만들고 싶어</code> 라고 썼겠지!
<ul>
<li>쿠키를 골랐을 때 초코가 나올 확률 &gt; 피자를 골랐을 때 초코가 나올 확률</li>
<li>피자를 골랐을 때 페퍼로니가 나올 확률 &gt; 쿠키를 골랐을 때 페퍼로니가 나올 확률</li>
</ul>
</li>
</ul>
</li>
<li>결국 문서를 작성한다는 것은, 이런 식으로 이루어질 것이다.
<ul>
<li><strong>문서 내에서 어떤 확률에 따라 주제를 고른다</strong>.
<ul>
<li>쿠키:50%, 관심: 50%, 피자 0%</li>
</ul>
</li>
<li><strong>주제는 각각 어떤 확률에 따라서 단어를 고른다.</strong>
<ul>
<li>쿠키라는 주제에 대해 각 단어가 등장할 확률은 초코칩: 40%, 충치: 10%, 페퍼로니 0% ….</li>
</ul>
</li>
<li>2개의 과정을 거쳐 만들어진 단어의 집합이 하나의 문서가 된다.</li>
</ul>
</li>
</ul>
<p>문제는 이 모든 과정이 <strong>잠재적</strong>이라는 것입니다.</p>
<p>이렇게 ‘문서를 쓰게 된 과정’을 상상해봤지만, 사실 우리는 이 과정의 세부 디테일을 모릅니다. <code>쿠키 50%, 관심 50%</code> 이런 정보는 문서 어디에도 써있지 않으며 우리가 알 수 있는 건 그 과정의 결과물인 <strong>단어들</strong> 뿐입니다. 즉 지금 우리가 해야 하는 것은 단어들을 보고, 미지의 확률값들을 추론하는 것입니다. (<code>숨기고 있지만 널 더 보고 싶어!</code>)</p>
<p>그래서 우리에게 필요한 것은 기본적으로 베이지안 추론입니다. 베이지안 추론은 간단하게,</p>
<ul>
<li>궁금한 사건에 대해 잘 모르지만 일단 특정 확률에 따라 발생한다고 믿어본다.(<strong>사전 확률 분포</strong>)</li>
<li>사건을 관측해서 추가적인 정보를 얻는다.</li>
<li>얻은 정보에 더 들어맞도록 내 가정을 수정한다. (<strong>사후 확률 분포</strong>)</li>
</ul>
<p>밑에서 더 자세히 살펴보겠지만 LDA가 바로 이런 방식으로 동작합니다. 여기서 관심 있는 사건이 문서이고, LDA는 주어진 문서가 가장 나올 법한 확률 분포를 찾아가는 과정이죠.</p>
<ul>
<li>왠지 이 문서는 피자에 대한 것일 것 같아. → 앗 피자 관련된 말이 하나도 안 나왔어. → 피자에 대한 문서는 아닐 수도 있겠군.</li>
</ul>
<p>이렇게 보면 나름 자연스러운 추론 과정이죠? 문제는 대충 ‘~에 대한 것일 것 같아’가 아니라 숫자로 된 파라미터를 가진 ‘확률 분포’가 필요하다는 것입니다. 그래서 이 때 다음 단어가 등장합니다.</p>
<br>
<h2 id="디리클레">디리클레<a hidden class="anchor" aria-hidden="true" href="#디리클레">#</a></h2>
<p>디리클레는 확률 분포의 이름입니다. 결론부터 말하면 <strong>디리클레 분포는 다항분포의 사전 켤레 분포이기 때문에</strong> 사용됩니다. 뭔 소리인지 모르겠으므로 풀어서 설명해 보겠습니다.</p>
<p>일단 다시 우리의 잠재적 가정으로 돌아가서, 주제가 정해졌을 때 단어를 고르는 상황을 상상해 봅시다. 주머니에 수많은 단어카드가 들어 있는데, 각 단어카드가 몇개씩 들어 있는지는 주제별 단어 분포에 따라 다를 것입니다. 주머니에 손을 넣어 아무 카드나 뽑는 걸 반복합니다. 독립적 시행이며, 같은 단어는 여러 번 반복해서 나올 수 있습니다.</p>
<p>이런 경우, 단어를 뽑은 결과는 <strong>다항분포를 따르지 않을까</strong> 생각해볼 수 있습니다. 다항분포의 확률질량함수(정해진 확률 파라미터에 따라 주어진 관측 결과가 나올 확률값을 돌려주는 함수라고 생각하면 됩니다)는 이렇게 생겼습니다.</p>
<p>$$ f(x_1, \dots, x_k ; n, p_1, \dots , p_k) = \frac{n!}{x_1! \dots x_k!} p_1^{x_1} \dots p_k^{x_k} $$</p>
<ul>
<li>$k$개의 단어가 있고, 각 단어가 나타날 확률이 각각 $p_1$, … $p_k$로 정해져 있을 때 , $n$번을 뽑았을 때 단어가 $x_1$, …, $x_k$개씩 나타날 확률은 위와 같다. ($p$는 확률이므로 $p$를 다 더한 값은 1이며, $x$를 다 더한 것은 $n$일 것.)</li>
<li>쉽게 말하면 다항분포는 주사위 10번 던졌는데 1이 3번, 4가 7번 나올 확률은 어떻게 돼? 라는 질문에 대한 답을 주는 분포다. 이 경우 모든 $p$가 1/6이고, $n$이 10이고, $x$는 (3,0,0,7,0,0)이므로 저 식에 따라서 확률을 계산할 수 있다.</li>
</ul>
<p>하지만 앞서 언급했듯 우리는 확률값을 전혀 모르기 때문에 사전 확률을 정한 다음 업데이트를 통해 사후 분포를 얻는 전략을 취할 겁니다. 그래서 사전 확률 분포를 뭐로 정할 것이냐의 문제인데요. 사전 확률 분포와 사후 확률 분포가 같은 가족군일 때 이들을 켤레분포라고 하며, 만약에 <strong>켤레 사전 분포(conjugate prior)를 사전 분포로 사용할 경우 사후 분포 업데이트에 필요한 계산이 매우 편해지기 때문에</strong> 켤레 사전 분포를 사전 분포로 고르게 됩니다.</p>
<ul>
<li>❓ <strong>(참고) 켤레 사전 분포</strong>
<ul>
<li>만약 단어가 2개밖에 없다면 → 이항분포(Binomial)
<ul>
<li>이항분포의 켤레 사전 분포는 베타 분포</li>
</ul>
</li>
<li>단어가 여러 개이면 → 다항분포(Multinomial)
<ul>
<li>다항 분포의 켤레 사전 분포는 디리클레 분포</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>다항분포의 켤레 사전 분포인 디리클레 분포를 살펴 보기 전에, 왜 따로 사전 분포가 필요한데? 사후 분포랑 뭐가 다른데? 라는 생각을 해보면,</p>
<ul>
<li>다항분포는 각 사건의 확률 정보를 파라미터로서 알고 있어야 한다. 즉 각 단어가 나올 확률을 안다고 가정하고, 그 설정 하에서 최종 관측치(문서)의 확률을 알 수 있게 된다.
<ul>
<li><code>p( 관측치 | 확률 정보)</code></li>
<li>주사위를 던지는데 각 숫자가 나올 확률은 1/6인데 이런 관측치가 나올 확률은?</li>
</ul>
</li>
<li>디리클레 분포는 이걸 거꾸로 한 것. 우리가 아는 건 최종 관측치(문서)일 뿐이므로, 문서가 주어졌을 때 각 단어의 확률이 어떨지를 나타내주는 함수이다. 관측치가 파라미터다.
<ul>
<li><code>p( 확률 정보 | 관측치 )</code></li>
<li>주사위를 던지는데 이런 관측치가 나왔는데 각 숫자가 나올 확률은?</li>
</ul>
</li>
</ul>
<p>디리클레 분포의 확률밀도함수는 이렇게 생겼습니다(다항분포와 달리 연속확률분포입니다).</p>
<p>$$ f(p_1, \dots, p_k ; \alpha_1, \dots, \alpha_k) = \frac{1}{ B(\alpha)} \prod_{i = 1}^k p_i^{\alpha_i-1} $$</p>
<p>$$ B(\alpha) = \frac{\prod_{i=1}^{k} \gamma (\alpha_i)}{\gamma (\sum^k_{i=1} \alpha_i)} $$</p>
<ul>
<li>우리가 관측하기로 총 $k$개의 단어가 있고, 각각 $\alpha$ 번씩 등장했을 때, 이 함수는 각 단어가 등장할 확률이 $p$일 확률값을 돌려준다. (역시 모든 $p$의 합은 1)</li>
<li>$B(\alpha)$는 $\alpha$ 값과 감마함수에 따라 결정되는 정규화 상수다.</li>
</ul>
<p>이해를 위해 단어가 3개 있다고 가정할 때 $\alpha$ 값에 따라 확률밀도함수가 어떻게 달라지는지 보겠습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/lda/pdf.png#center"
         alt="그림 출처" width="380"/> <figcaption>
            <p><a href="https://en.wikipedia.org/wiki/Dirichlet_distribution">그림 출처</a></p>
        </figcaption>
</figure>

<ul>
<li>위: 3개가 모두 동일한 횟수로 (5번씩) 나왔는데 각 단어가 등장할 확률은 아마 비슷하겠지?</li>
<li>아래: 세번째 단어가 8번 나오는 동안 첫번째, 두번째 단어는 2번, 4번 나왔는데 3번째 단어가 나올 확률이 제일 높겠지?</li>
</ul>
<p>이제 LDA가 가정하는 잠재적인 과정과 이용하는 확률 분포에 대해 알았습니다. 마지막 단어로 넘어가서, LDA가 실제로 어떻게 주제를 찾는지 알아보겠습니다.</p>
<br>
<h2 id="할당">할당<a hidden class="anchor" aria-hidden="true" href="#할당">#</a></h2>
<p>LDA의 최종 목표는 단어별로 문서별로 주제를 할당하는 것입니다. 어떻게 할까요? 그 과정은 다음과 같이 하나의 도식으로 나타낼 수 있습니다.</p>
<figure class="align-center ">
    <img loading="lazy" src="/posts/lda/lda.png#center"
         alt="그림 출처" width="600"/> <figcaption>
            <p><a href="https://www.researchgate.net/figure/Graphical-model-of-latent-Dirichlet-allocation-LDA_fig1_326140642">그림 출처</a></p>
        </figcaption>
</figure>

<ul>
<li>2개의 분포가 있다.
<ol>
<li>문서마다 있는 주제 분포 (Document-Topic distribution)
<ul>
<li>$M$개의 문서가 존재 (분포도 $M$개!)</li>
<li>$\theta_m \sim \text{Dir}(\alpha)$ : $\alpha$ 라는 파라미터를 지닌 디리클레 분포를 사전분포로 쓰겠다는 뜻.
<ul>
<li>$\theta$는 그 문서에서 주제에 대한 확률값 벡터가 된다. ex) <code>쿠키:50%, 관심: 50%, 피자 0%</code></li>
</ul>
</li>
</ul>
</li>
<li>주제마다 있는 단어 분포 (Topic-Word Distribution)
<ul>
<li>$K$개의 주제가 존재 (분포도 $K$개!)</li>
<li>$\varphi_k \sim \text{Dir}(\beta)$ : $\beta$라는 파라미터를 지닌 디리클레 분포를 사전분포로 쓰겠다는 뜻.
<ul>
<li>$\varphi$ 는 그 주제에서 단어에 대한 확률값 벡터가 된다. ex) <code>초코칩: 40%, 충치: 10%, 페퍼로니 0% ….</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>관측된 단어(Obsered Word)에 주제를 할당(Word-Topic assignment) 해보자.
<ul>
<li>$N$개의 단어가 존재</li>
<li>각 문서에 존재하는 관측된 단어 $w_{m,n}$ 에 대해 주제 $z_{m,n}$을 정해보자.</li>
<li>두가지 분포의 결합으로 단어가 나타난다. 즉 단어의 결정은 문서-주제 분포로 결정된 주제($z$)와 그 주제의 주제-단어 분포를 결정하는 파라미터($\beta$)의 영향을 받는데,
<ul>
<li>$p(w_n \mid z_n, \beta)$</li>
<li>이 확률이 컸으면 좋겠다 = 이 확률이 커지는 주제를 할당하고 싶다.</li>
<li>이 추론 방식을 풀어 쓰면, <code>초코칩이라는 단어가 나타난 것은 이 문서가 쿠키라는 주제가 높은 확률로 등장하는 분포이기 때문에, 쿠키라는 주제는 초코칩이 높은 확률로 등장하는 분포이기 때문에…</code> 이 ‘때문에’가 말이 되려면 이 여러 개의 변수 중 우리가 모르는 값들을(사실 $w$ 빼고 다 모름) 관측된 사건의 확률을 크게 해주는 방향으로 설정해주면 된다. 결국 단어에 주제를 할당할 때 목적은, <strong>우리가 가정한 분포와 잠재적 과정이 우리가 실제로 관측한 단어를 최대한 잘 설명할 수 있도록 하는 것</strong>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>LDA는 이 목적을 달성하기 위해 베이지안 통계에서 자주 등장하는 깁스 샘플링(Gibbs Sampling)이라는 기법을 사용합니다. 단어의 개수가 많아질수록 우리가 추정해야 하는 값들의 차원이 엄청나게 늘어나기 때문에 추론에 필요한 계산을 가능하게 해주는 방법입니다.</p>
<p>전체 과정을 순서대로 설명하면 다음과 같습니다. 토픽의 개수인 $K$는 미리 지정해 주어야 합니다. 사전분포의 파라미터 값들($\alpha,$ $\beta$)도요.</p>
<ol>
<li>모든 단어에 아무 주제나 할당한다. 그러면 이 값에 따라 우리의 관심사인 2개의 분포가 결정된다.
<ul>
<li>아무렇게나 정했기 때문에 당연히 엉망일 것이다. 이제 업데이트를 하자.</li>
</ul>
</li>
<li>1개의 단어를 고르고, 이 1개의 단어를 제외하고 나머지 단어들은 다 정답인 주제로 배정되어 있다고 가정한다.
<ul>
<li>나머지 단어들만 사용해서 이 문서의 주제 분포와 각 주제의 단어분포를 다시 계산한다.</li>
<li>이 분포를 기반으로 이 1개의 단어에 각 주제가 할당될 확률을 계산한 후 $p(z_i \mid z_{-i}, w)$ 가장 확률이 높은 주제로 재할당한다.
<ul>
<li>P(주제 $\mid$ 분포) x P(단어 $\mid$ 주제) 를 나머지 단어들의 카운트를 통해 계산하면 된다. 지금까지 설명한 단어 선정 방식과 직관적으로 일치하는 내용.</li>
</ul>
</li>
</ul>
</li>
<li>문서 내 모든 단어에 대해 이것을 반복한다. 이것이 1회의 깁스 샘플링이다.</li>
<li>샘플링(재할당)을 반복하다보면 더 이상 변동이 없이 안정적으로 수렴하는 순간이 올 것이다. 거기서 멈춘다.</li>
<li>멈췄을 때 얻은 모든 단어의 주제 분포를 사용해서 단어의 집합인 각 문서에 주제를 할당한다.</li>
</ol>
<br>
<h2 id="참고한-글들">참고한 글들<a hidden class="anchor" aria-hidden="true" href="#참고한-글들">#</a></h2>
<ul>
<li><a href="https://ratsgo.github.io/from%20frequency%20to%20semantics/2017/06/01/LDA/">Topic Modeling, LDA</a></li>
<li><a href="https://bab2min.tistory.com/568?category=673750">잠재 디리클레 할당 파헤치기 2. 디리클레 분포와 LDA</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sliceofdata.app/tags/nlp/">Nlp</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 잠재 디리클레 할당 (LDA) 뜯어보기 on x"
            href="https://x.com/intent/tweet/?text=%ec%9e%a0%ec%9e%ac%20%eb%94%94%eb%a6%ac%ed%81%b4%eb%a0%88%20%ed%95%a0%eb%8b%b9%20%28LDA%29%20%eb%9c%af%ec%96%b4%eb%b3%b4%ea%b8%b0&amp;url=https%3a%2f%2fsliceofdata.app%2fposts%2flda%2f&amp;hashtags=nlp">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 잠재 디리클레 할당 (LDA) 뜯어보기 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsliceofdata.app%2fposts%2flda%2f&amp;title=%ec%9e%a0%ec%9e%ac%20%eb%94%94%eb%a6%ac%ed%81%b4%eb%a0%88%20%ed%95%a0%eb%8b%b9%20%28LDA%29%20%eb%9c%af%ec%96%b4%eb%b3%b4%ea%b8%b0&amp;summary=%ec%9e%a0%ec%9e%ac%20%eb%94%94%eb%a6%ac%ed%81%b4%eb%a0%88%20%ed%95%a0%eb%8b%b9%20%28LDA%29%20%eb%9c%af%ec%96%b4%eb%b3%b4%ea%b8%b0&amp;source=https%3a%2f%2fsliceofdata.app%2fposts%2flda%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
<div class="container_disqus">
    <script src="https://giscus.app/client.js"
        data-repo="pizzathiefz/sliceofdata"
        data-repo-id="R_kgDOPsr6oQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOPsr6oc4CvOfW"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme=""
        data-lang="en"
        crossorigin="anonymous"
        async>
    </script>
</div>
<script>
    
    function getCurrentTheme() {
        
        let storedTheme = localStorage.getItem('pref-theme');
        if (storedTheme) {
            return storedTheme;
        }
        
        
        if (document.body.classList.contains('dark')) {
            return 'dark';
        }
        
        
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        
        return 'light';
    }
    
    
    function setGiscusTheme() {
        let currentTheme = getCurrentTheme();
        let giscusTheme = currentTheme === 'dark' ? 'noborder_dark' : 'noborder_light';
        
        
        let giscusScript = document.querySelector("div.container_disqus > script");
        if (giscusScript) {
            giscusScript.setAttribute('data-theme', giscusTheme);
        }
        
        return giscusTheme;
    }
    
    
    setGiscusTheme();
    
    
    document.addEventListener('DOMContentLoaded', function() {
        let themeToggle = document.querySelector('#theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                setTimeout(() => {
                    let newTheme = getCurrentTheme();
                    let newGiscusTheme = newTheme === 'dark' ? 'noborder_dark' : 'noborder_light';
                    
                    let giscusFrame = document.querySelector('iframe.giscus-frame');
                    if (giscusFrame) {
                        giscusFrame.contentWindow.postMessage({
                            giscus: {
                                setConfig: {
                                    theme: newGiscusTheme
                                }
                            }
                        }, 'https://giscus.app');
                    }
                }, 100);
            });
        }
    });
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://sliceofdata.app/">sliceofdata</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
